[
  {
    "id": "1",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction sayHi() {\n  console.log(name);\n  console.log(age);\n  var name = \u0027Lydia\u0027;\n  let age = 21;\n}\n\nsayHi();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Lydia and undefined",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Lydia and ReferenceError",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "ReferenceError and 21",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined and ReferenceError",
        "isCorrect": true
      }
    ],
    "explanation": "Within the function, we first declare the \u0060name\u0060 variable with the \u0060var\u0060 keyword. This means that the variable gets hoisted (memory space is set up during the creation phase) with the default value of \u0060undefined\u0060, until we actually get to the line where we define the variable. We haven\u0027t defined the variable yet on the line where we try to log the \u0060name\u0060 variable, so it still holds the value of \u0060undefined\u0060.\n\nVariables with the \u0060let\u0060 keyword (and \u0060const\u0060) are hoisted, but unlike \u0060var\u0060, don\u0027t get \u003Ci\u003Einitialized\u003C/i\u003E. They are not accessible before the line we declare (initialize) them. This is called the \u0022temporal dead zone\u0022. When we try to access the variables before they are declared, JavaScript throws a \u0060ReferenceError\u0060."
  },
  {
    "id": "2",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfor (var i = 0; i \u003C 3; i\u002B\u002B) {\n  setTimeout(() =\u003E console.log(i), 1);\n}\n\nfor (let i = 0; i \u003C 3; i\u002B\u002B) {\n  setTimeout(() =\u003E console.log(i), 1);\n}\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "0 1 2 and 0 1 2",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "0 1 2 and 3 3 3",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "3 3 3 and 0 1 2",
        "isCorrect": true
      }
    ],
    "explanation": "Because of the event queue in JavaScript, the \u0060setTimeout\u0060 callback function is called _after_ the loop has been executed. Since the variable \u0060i\u0060 in the first loop was declared using the \u0060var\u0060 keyword, this value was global. During the loop, we incremented the value of \u0060i\u0060 by \u00601\u0060 each time, using the unary operator \u0060\u002B\u002B\u0060. By the time the \u0060setTimeout\u0060 callback function was invoked, \u0060i\u0060 was equal to \u00603\u0060 in the first example.\n\nIn the second loop, the variable \u0060i\u0060 was declared using the \u0060let\u0060 keyword: variables declared with the \u0060let\u0060 (and \u0060const\u0060) keyword are block-scoped (a block is anything between \u0060{ }\u0060). During each iteration, \u0060i\u0060 will have a new value, and each value is scoped inside the loop."
  },
  {
    "id": "3",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst shape = {\n  radius: 10,\n  diameter() {\n    return this.radius * 2;\n  },\n  perimeter: () =\u003E 2 * Math.PI * this.radius,\n};\n\nconsole.log(shape.diameter());\nconsole.log(shape.perimeter());\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "20 and 62.83185307179586",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "20 and NaN",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "20 and 63",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "NaN and 63",
        "isCorrect": false
      }
    ],
    "explanation": "Note that the value of \u0060diameter\u0060 is a regular function, whereas the value of \u0060perimeter\u0060 is an arrow function.\n\nWith arrow functions, the \u0060this\u0060 keyword refers to its current surrounding scope, unlike regular functions! This means that when we call \u0060perimeter\u0060, it doesn\u0027t refer to the shape object, but to its surrounding scope (window for example).\n\nThere is no value \u0060radius\u0060 on that object, which returns \u0060NaN\u0060."
  },
  {
    "id": "4",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\n\u002Btrue;\n!\u0027Lydia\u0027;\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "1 and false",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "false and NaN",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "false and false",
        "isCorrect": false
      }
    ],
    "explanation": "The unary plus tries to convert an operand to a number. \u0060true\u0060 is \u00601\u0060, and \u0060false\u0060 is \u00600\u0060.\n\nThe string \u0060\u0027Lydia\u0027\u0060 is a truthy value. What we\u0027re actually asking, is \u0022is this truthy value falsy?\u0022. This returns \u0060false\u0060."
  },
  {
    "id": "5",
    "question": "Which one is true?\n\n\u0060\u0060\u0060javascript\nconst bird = {\n  size: \u0027small\u0027,\n};\n\nconst mouse = {\n  name: \u0027Mickey\u0027,\n  small: true,\n};\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "mouse.bird.size is not valid",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "mouse[bird.size] is not valid",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "mouse[bird[\u0022size\u0022]] is not valid",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "All of them are valid",
        "isCorrect": false
      }
    ],
    "explanation": "In JavaScript, all object keys are strings (unless it\u0027s a Symbol). Even though we might not _type_ them as strings, they are always converted into strings under the hood.\n\nJavaScript interprets (or unboxes) statements. When we use bracket notation, it sees the first opening bracket \u0060[\u0060 and keeps going until it finds the closing bracket \u0060]\u0060. Only then, it will evaluate the statement.\n\n\u0060mouse[bird.size]\u0060: First it evaluates \u0060bird.size\u0060, which is \u0060\u0022small\u0022\u0060. \u0060mouse[\u0022small\u0022]\u0060 returns \u0060true\u0060\n\nHowever, with dot notation, this doesn\u0027t happen. \u0060mouse\u0060 does not have a key called \u0060bird\u0060, which means that \u0060mouse.bird\u0060 is \u0060undefined\u0060. Then, we ask for the \u0060size\u0060 using dot notation: \u0060mouse.bird.size\u0060. Since \u0060mouse.bird\u0060 is \u0060undefined\u0060, we\u0027re actually asking \u0060undefined.size\u0060. This isn\u0027t valid, and will throw an error similar to \u0060Cannot read property \u0022size\u0022 of undefined\u0060."
  },
  {
    "id": "6",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nlet c = { greeting: \u0027Hey!\u0027 };\nlet d;\n\nd = c;\nc.greeting = \u0027Hello\u0027;\nconsole.log(d.greeting);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Hello",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "Hey!",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      },
      {
        "index": "E",
        "answer": "TypeError",
        "isCorrect": false
      }
    ],
    "explanation": "In JavaScript, all objects interact by _reference_ when setting them equal to each other.\n\nFirst, variable \u0060c\u0060 holds a value to an object. Later, we assign \u0060d\u0060 with the same reference that \u0060c\u0060 has to the object.\n\n\u003Cimg src=\u0022https://i.imgur.com/ko5k0fs.png\u0022 width=\u0022200\u0022\u003E\n\nWhen you change one object, you change all of them."
  },
  {
    "id": "7",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nlet a = 3;\nlet b = new Number(3);\nlet c = 3;\n\nconsole.log(a == b);\nconsole.log(a === b);\nconsole.log(b === c);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "true false true",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "false false true",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "true false false",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "false true true",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060new Number()\u0060 is a built-in function constructor. Although it looks like a number, it\u0027s not really a number: it has a bunch of extra features and is an object.\n\nWhen we use the \u0060==\u0060 operator, it only checks whether it has the same _value_. They both have the value of \u00603\u0060, so it returns \u0060true\u0060.\n\nHowever, when we use the \u0060===\u0060 operator, both value _and_ type should be the same. It\u0027s not: \u0060new Number()\u0060 is not a number, it\u0027s an **object**. Both return \u0060false.\u0060"
  },
  {
    "id": "8",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nclass Chameleon {\n  static colorChange(newColor) {\n    this.newColor = newColor;\n    return this.newColor;\n  }\n\n  constructor({ newColor = \u0027green\u0027 } = {}) {\n    this.newColor = newColor;\n  }\n}\n\nconst freddie = new Chameleon({ newColor: \u0027purple\u0027 });\nconsole.log(freddie.colorChange(\u0027orange\u0027));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "orange",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "purple",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "green",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "TypeError",
        "isCorrect": true
      }
    ],
    "explanation": "The \u0060colorChange\u0060 function is static. Static methods are designed to live only on the constructor in which they are created, and cannot be passed down to any children or called upon class instances. Since \u0060freddie\u0060 is an instance of class Chameleon, the function cannot be called upon it. A \u0060TypeError\u0060 is thrown."
  },
  {
    "id": "9",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nlet greeting;\ngreetign = {}; // Typo!\nconsole.log(greetign);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{}",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "ReferenceError: greetign is not defined",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": false
      }
    ],
    "explanation": "It logs the object, because we just created an empty object on the global object! When we mistyped \u0060greeting\u0060 as \u0060greetign\u0060, the JS interpreter actually saw this as \u0060global.greetign = {}\u0060 (or \u0060window.greetign = {}\u0060 in a browser).\n\nIn order to avoid this, we can use \u0060\u0022use strict\u0022\u0060. This makes sure that you have declared a variable before setting it equal to anything."
  },
  {
    "id": "10",
    "question": "What happens when we do this?\n\n\u0060\u0060\u0060javascript\nfunction bark() {\n  console.log(\u0027Woof!\u0027);\n}\n\nbark.animal = \u0027dog\u0027;\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Nothing, this is totally fine!",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "SyntaxError. You cannot add properties to a function this way.",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "\u0022Woof\u0022 gets logged.",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "This is possible in JavaScript, because functions are objects! (Everything besides primitive types are objects)\n\nA function is a special type of object. The code you write yourself isn\u0027t the actual function. The function is an object with properties. This property is invocable."
  },
  {
    "id": "11",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst member = new Person(\u0027Lydia\u0027, \u0027Hallie\u0027);\nPerson.getFullName = function() {\n  return \u0060${this.firstName} ${this.lastName}\u0060;\n};\n\nconsole.log(member.getFullName());\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "TypeError",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "SyntaxError",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Lydia Hallie",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined undefined",
        "isCorrect": false
      }
    ],
    "explanation": "In JavaScript, functions are objects, and therefore, the method \u0060getFullName\u0060 gets added to the constructor function object itself. For that reason, we can call \u0060Person.getFullName()\u0060, but \u0060member.getFullName\u0060 throws a \u0060TypeError\u0060. \n\nIf you want a method to be available to all object instances, you have to add it to the prototype property:\n\n\u0060\u0060\u0060js\nPerson.prototype.getFullName = function() {\n  return \u0060${this.firstName} ${this.lastName}\u0060;\n};\n\u0060\u0060\u0060"
  },
  {
    "id": "12",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\nconst lydia = new Person(\u0027Lydia\u0027, \u0027Hallie\u0027);\nconst sarah = Person(\u0027Sarah\u0027, \u0027Smith\u0027);\n\nconsole.log(lydia);\nconsole.log(sarah);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Person {firstName: \u0022Lydia\u0022, lastName: \u0022Hallie\u0022} and undefined",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "Person {firstName: \u0022Lydia\u0022, lastName: \u0022Hallie\u0022} and Person {firstName: \u0022Sarah\u0022, lastName: \u0022Smith\u0022}",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Person {firstName: \u0022Lydia\u0022, lastName: \u0022Hallie\u0022} and {}",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Person {firstName: \u0022Lydia\u0022, lastName: \u0022Hallie\u0022} and ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "For \u0060sarah\u0060, we didn\u0027t use the \u0060new\u0060 keyword. When using \u0060new\u0060, \u0060this\u0060 refers to the new empty object we create. However, if you don\u0027t add \u0060new\u0060, \u0060this\u0060 refers to the **global object**!\n\nWe said that \u0060this.firstName\u0060 equals \u0060\u0022Sarah\u0022\u0060 and \u0060this.lastName\u0060 equals \u0060\u0022Smith\u0022\u0060. What we actually did, is defining \u0060global.firstName = \u0027Sarah\u0027\u0060 and \u0060global.lastName = \u0027Smith\u0027\u0060. \u0060sarah\u0060 itself is left \u0060undefined\u0060, since we don\u0027t return a value from the \u0060Person\u0060 function."
  },
  {
    "id": "13",
    "question": "What are the three phases of event propagation?",
    "answers": [
      {
        "index": "A",
        "answer": "Target \u003E Capturing \u003E Bubbling",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Bubbling \u003E Target \u003E Capturing",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Target \u003E Bubbling \u003E Capturing",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Capturing \u003E Target \u003E Bubbling",
        "isCorrect": true
      }
    ],
    "explanation": "During the **capturing** phase, the event goes through the ancestor elements down to the target element. It then reaches the **target** element, and **bubbling** begins.\n\n\u003Cimg src=\u0022https://i.imgur.com/N18oRgd.png\u0022 width=\u0022200\u0022\u003E"
  },
  {
    "id": "14",
    "question": "All object have prototypes.",
    "answers": [
      {
        "index": "A",
        "answer": "true",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "false",
        "isCorrect": true
      }
    ],
    "explanation": "All objects have prototypes, except for the **base object**. The base object is the object created by the user, or an object that is created using the \u0060new\u0060 keyword. The base object has access to some methods and properties, such as \u0060.toString\u0060. This is the reason why you can use built-in JavaScript methods! All of such methods are available on the prototype. Although JavaScript can\u0027t find it directly on your object, it goes down the prototype chain and finds it there, which makes it accessible for you."
  },
  {
    "id": "15",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction sum(a, b) {\n  return a \u002B b;\n}\n\nsum(1, \u00272\u0027);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "NaN",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "TypeError",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "\u002212\u0022",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "3",
        "isCorrect": false
      }
    ],
    "explanation": "JavaScript is a **dynamically typed language**: we don\u0027t specify what types certain variables are. Values can automatically be converted into another type without you knowing, which is called _implicit type coercion_. **Coercion** is converting from one type into another.\n\nIn this example, JavaScript converts the number \u00601\u0060 into a string, in order for the function to make sense and return a value. During the addition of a numeric type (\u00601\u0060) and a string type (\u0060\u00272\u0027\u0060), the number is treated as a string. We can concatenate strings like \u0060\u0022Hello\u0022 \u002B \u0022World\u0022\u0060, so what\u0027s happening here is \u0060\u00221\u0022 \u002B \u00222\u0022\u0060 which returns \u0060\u002212\u0022\u0060."
  },
  {
    "id": "16",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nlet number = 0;\nconsole.log(number\u002B\u002B);\nconsole.log(\u002B\u002Bnumber);\nconsole.log(number);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "1 1 2",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "1 2 2",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "0 2 2",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "0 1 2",
        "isCorrect": false
      }
    ],
    "explanation": "The **postfix** unary operator \u0060\u002B\u002B\u0060:\n\n1. Returns the value (this returns \u00600\u0060)\n2. Increments the value (number is now \u00601\u0060)\n\nThe **prefix** unary operator \u0060\u002B\u002B\u0060:\n\n1. Increments the value (number is now \u00602\u0060)\n2. Returns the value (this returns \u00602\u0060)\n\nThis returns \u00600 2 2\u0060."
  },
  {
    "id": "17",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction getPersonInfo(one, two, three) {\n  console.log(one);\n  console.log(two);\n  console.log(three);\n}\n\nconst person = \u0027Lydia\u0027;\nconst age = 21;\n\ngetPersonInfo\u0060${person} is ${age} years old\u0060;\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022Lydia\u0022 21 [\u0022\u0022, \u0022 is \u0022, \u0022 years old\u0022]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[\u0022\u0022, \u0022 is \u0022, \u0022 years old\u0022] \u0022Lydia\u0022 21",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "\u0022Lydia\u0022 [\u0022\u0022, \u0022 is \u0022, \u0022 years old\u0022] 21",
        "isCorrect": false
      }
    ],
    "explanation": "If you use tagged template literals, the value of the first argument is always an array of the string values. The remaining arguments get the values of the passed expressions!"
  },
  {
    "id": "18",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction checkAge(data) {\n  if (data === { age: 18 }) {\n    console.log(\u0027You are an adult!\u0027);\n  } else if (data == { age: 18 }) {\n    console.log(\u0027You are still an adult.\u0027);\n  } else {\n    console.log(\u0060Hmm.. You don\u0027t have an age I guess\u0060);\n  }\n}\n\ncheckAge({ age: 18 });\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "You are an adult!",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "You are still an adult.",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Hmm.. You don\u0027t have an age I guess",
        "isCorrect": true
      }
    ],
    "explanation": "When testing equality, primitives are compared by their _value_, while objects are compared by their _reference_. JavaScript checks if the objects have a reference to the same location in memory.\n\nThe two objects that we are comparing don\u0027t have that: the object we passed as a parameter refers to a different location in memory than the object we used in order to check equality.\n\nThis is why both \u0060{ age: 18 } === { age: 18 }\u0060 and \u0060{ age: 18 } == { age: 18 }\u0060 return \u0060false\u0060."
  },
  {
    "id": "19",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction getAge(...args) {\n  console.log(typeof args);\n}\n\ngetAge(21);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022number\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022array\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "\u0022object\u0022",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "\u0022NaN\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "The rest parameter (\u0060...args\u0060) lets us \u0022collect\u0022 all remaining arguments into an array. An array is an object, so \u0060typeof args\u0060 returns \u0060\u0022object\u0022\u0060"
  },
  {
    "id": "20",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction getAge() {\n  \u0027use strict\u0027;\n  age = 21;\n  console.log(age);\n}\n\ngetAge();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "21",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "undefined",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "ReferenceError",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "TypeError",
        "isCorrect": false
      }
    ],
    "explanation": "With \u0060\u0022use strict\u0022\u0060, you can make sure that you don\u0027t accidentally declare global variables. We never declared the variable \u0060age\u0060, and since we use \u0060\u0022use strict\u0022\u0060, it will throw a reference error. If we didn\u0027t use \u0060\u0022use strict\u0022\u0060, it would have worked, since the property \u0060age\u0060 would have gotten added to the global object."
  },
  {
    "id": "21",
    "question": "What\u0027s the value of \u0060sum\u0060?\n\n\u0060\u0060\u0060javascript\nconst sum = eval(\u002710*10\u002B5\u0027);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "105",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "\u0022105\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "TypeError",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "\u002210*10\u002B5\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060eval\u0060 evaluates codes that\u0027s passed as a string. If it\u0027s an expression, like in this case, it evaluates the expression. The expression is \u006010 * 10 \u002B 5\u0060. This returns the number \u0060105\u0060."
  },
  {
    "id": "22",
    "question": "How long is cool_secret accessible?\n\n\u0060\u0060\u0060javascript\nsessionStorage.setItem(\u0027cool_secret\u0027, 123);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Forever, the data doesn\u0027t get lost.",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "When the user closes the tab.",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "When the user closes the entire browser, not only the tab.",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "When the user shuts off their computer.",
        "isCorrect": false
      }
    ],
    "explanation": "The data stored in \u0060sessionStorage\u0060 is removed after closing the _tab_.\n\nIf you used \u0060localStorage\u0060, the data would\u0027ve been there forever, unless for example \u0060localStorage.clear()\u0060 is invoked."
  },
  {
    "id": "23",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nvar num = 8;\nvar num = 10;\n\nconsole.log(num);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "8",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "10",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "SyntaxError",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060var\u0060 keyword, you can declare multiple variables with the same name. The variable will then hold the latest value.\n\nYou cannot do this with \u0060let\u0060 or \u0060const\u0060 since they\u0027re block-scoped."
  },
  {
    "id": "24",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst obj = { 1: \u0027a\u0027, 2: \u0027b\u0027, 3: \u0027c\u0027 };\nconst set = new Set([1, 2, 3, 4, 5]);\n\nobj.hasOwnProperty(\u00271\u0027);\nobj.hasOwnProperty(1);\nset.has(\u00271\u0027);\nset.has(1);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "false true false true",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "false true true true",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "true true false true",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "true true true true",
        "isCorrect": false
      }
    ],
    "explanation": "All object keys (excluding Symbols) are strings under the hood, even if you don\u0027t type it yourself as a string. This is why \u0060obj.hasOwnProperty(\u00271\u0027)\u0060 also returns true.\n\nIt doesn\u0027t work that way for a set. There is no \u0060\u00271\u0027\u0060 in our set: \u0060set.has(\u00271\u0027)\u0060 returns \u0060false\u0060. It has the numeric type \u00601\u0060, \u0060set.has(1)\u0060 returns \u0060true\u0060."
  },
  {
    "id": "25",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst obj = { a: \u0027one\u0027, b: \u0027two\u0027, a: \u0027three\u0027 };\nconsole.log(obj);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{ a: \u0022one\u0022, b: \u0022two\u0022 }",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "{ b: \u0022two\u0022, a: \u0022three\u0022 }",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "{ a: \u0022three\u0022, b: \u0022two\u0022 }",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "SyntaxError",
        "isCorrect": false
      }
    ],
    "explanation": "If you have two keys with the same name, the key will be replaced. It will still be in its first position, but with the last specified value."
  },
  {
    "id": "26",
    "question": "The JavaScript global execution context creates two things for you: the global object, and the \u0022this\u0022 keyword.",
    "answers": [
      {
        "index": "A",
        "answer": "true",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "false",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "it depends",
        "isCorrect": false
      }
    ],
    "explanation": "The base execution context is the global execution context: it\u0027s what\u0027s accessible everywhere in your code."
  },
  {
    "id": "27",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfor (let i = 1; i \u003C 5; i\u002B\u002B) {\n  if (i === 3) continue;\n  console.log(i);\n}\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "1 2",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "1 2 3",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "1 2 4",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "1 3 4",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060continue\u0060 statement skips an iteration if a certain condition returns \u0060true\u0060."
  },
  {
    "id": "28",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nString.prototype.giveLydiaPizza = () =\u003E {\n  return \u0027Just give Lydia pizza already!\u0027;\n};\n\nconst name = \u0027Lydia\u0027;\n\nconsole.log(name.giveLydiaPizza())\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022Just give Lydia pizza already!\u0022",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "TypeError: not a function",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "SyntaxError",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060String\u0060 is a built-in constructor, which we can add properties to. I just added a method to its prototype. Primitive strings are automatically converted into a string object, generated by the string prototype function. So, all strings (string objects) have access to that method!"
  },
  {
    "id": "29",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst a = {};\nconst b = { key: \u0027b\u0027 };\nconst c = { key: \u0027c\u0027 };\n\na[b] = 123;\na[c] = 456;\n\nconsole.log(a[b]);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "123",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "456",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "Object keys are automatically converted into strings. We are trying to set an object as a key to object \u0060a\u0060, with the value of \u0060123\u0060.\n\nHowever, when we stringify an object, it becomes \u0060\u0022[object Object]\u0022\u0060. So what we are saying here, is that \u0060a[\u0022[object Object]\u0022] = 123\u0060. Then, we can try to do the same again. \u0060c\u0060 is another object that we are implicitly stringifying. So then, \u0060a[\u0022[object Object]\u0022] = 456\u0060.\n\nThen, we log \u0060a[b]\u0060, which is actually \u0060a[\u0022[object Object]\u0022]\u0060. We just set that to \u0060456\u0060, so it returns \u0060456\u0060."
  },
  {
    "id": "30",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst foo = () =\u003E console.log(\u0027First\u0027);\nconst bar = () =\u003E setTimeout(() =\u003E console.log(\u0027Second\u0027));\nconst baz = () =\u003E console.log(\u0027Third\u0027);\n\nbar();\nfoo();\nbaz();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "First Second Third",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "First Third Second",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "Second First Third",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Second Third First",
        "isCorrect": false
      }
    ],
    "explanation": "We have a \u0060setTimeout\u0060 function and invoked it first. Yet, it was logged last.\n\nThis is because in browsers, we don\u0027t just have the runtime engine, we also have something called a \u0060WebAPI\u0060. The \u0060WebAPI\u0060 gives us the \u0060setTimeout\u0060 function to start with, and for example the DOM.\n\nAfter the _callback_ is pushed to the WebAPI, the \u0060setTimeout\u0060 function itself (but not the callback!) is popped off the stack.\n\n\u003Cimg src=\u0022https://i.imgur.com/X5wsHOg.png\u0022 width=\u0022200\u0022\u003E\n\nNow, \u0060foo\u0060 gets invoked, and \u0060\u0022First\u0022\u0060 is being logged.\n\n\u003Cimg src=\u0022https://i.imgur.com/Pvc0dGq.png\u0022 width=\u0022200\u0022\u003E\n\n\u0060foo\u0060 is popped off the stack, and \u0060baz\u0060 gets invoked. \u0060\u0022Third\u0022\u0060 gets logged.\n\n\u003Cimg src=\u0022https://i.imgur.com/WhA2bCP.png\u0022 width=\u0022200\u0022\u003E\n\nThe WebAPI can\u0027t just add stuff to the stack whenever it\u0027s ready. Instead, it pushes the callback function to something called the _queue_.\n\n\u003Cimg src=\u0022https://i.imgur.com/NSnDZmU.png\u0022 width=\u0022200\u0022\u003E\n\nThis is where an event loop starts to work. An **event loop** looks at the stack and task queue. If the stack is empty, it takes the first thing on the queue and pushes it onto the stack.\n\n\u003Cimg src=\u0022https://i.imgur.com/uyiScAI.png\u0022 width=\u0022200\u0022\u003E\n\n\u0060bar\u0060 gets invoked, \u0060\u0022Second\u0022\u0060 gets logged, and it\u0027s popped off the stack."
  },
  {
    "id": "31",
    "question": "What is the event.target when clicking the button?\n\n\u0060\u0060\u0060html\n\u003Cdiv onclick=\u0022console.log(\u0027first div\u0027)\u0022\u003E\n  \u003Cdiv onclick=\u0022console.log(\u0027second div\u0027)\u0022\u003E\n    \u003Cbutton onclick=\u0022console.log(\u0027button\u0027)\u0022\u003E\n      Click!\n    \u003C/button\u003E\n  \u003C/div\u003E\n\u003C/div\u003E\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Outer div",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Inner div",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "button",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "An array of all nested elements.",
        "isCorrect": false
      }
    ],
    "explanation": "The deepest nested element that caused the event is the target of the event. You can stop bubbling by \u0060event.stopPropagation\u0060"
  },
  {
    "id": "32",
    "question": "When you click the paragraph, what\u0027s the logged output?\n\n\u0060\u0060\u0060html\n\u003Cdiv onclick=\u0022console.log(\u0027div\u0027)\u0022\u003E\n  \u003Cp onclick=\u0022console.log(\u0027p\u0027)\u0022\u003E\n    Click here!\n  \u003C/p\u003E\n\u003C/div\u003E\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "p div",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "div p",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "p",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "div",
        "isCorrect": false
      }
    ],
    "explanation": "If we click \u0060p\u0060, we see two logs: \u0060p\u0060 and \u0060div\u0060. During event propagation, there are 3 phases: capturing, target, and bubbling. By default, event handlers are executed in the bubbling phase (unless you set \u0060useCapture\u0060 to \u0060true\u0060). It goes from the deepest nested element outwards."
  },
  {
    "id": "33",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst person = { name: \u0027Lydia\u0027 };\n\nfunction sayHi(age) {\n  return \u0060${this.name} is ${age}\u0060;\n}\n\nconsole.log(sayHi.call(person, 21));\nconsole.log(sayHi.bind(person, 21));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "undefined is 21 Lydia is 21",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "function function",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Lydia is 21 Lydia is 21",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Lydia is 21 function",
        "isCorrect": true
      }
    ],
    "explanation": "With both, we can pass the object to which we want the \u0060this\u0060 keyword to refer to. However, \u0060.call\u0060 is also _executed immediately_!\n\n\u0060.bind.\u0060 returns a _copy_ of the function, but with a bound context! It is not executed immediately."
  },
  {
    "id": "34",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction sayHi() {\n  return (() =\u003E 0)();\n}\n\nconsole.log(typeof sayHi());\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022object\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022number\u0022",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "\u0022function\u0022",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "\u0022undefined\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060sayHi\u0060 function returns the returned value of the immediately invoked function expression (IIFE). This function returned \u00600\u0060, which is type \u0060\u0022number\u0022\u0060.\n\t\nFYI: \u0060typeof\u0060 can return the following list of values: \u0060undefined\u0060, \u0060boolean\u0060, \u0060number\u0060, \u0060bigint\u0060, \u0060string\u0060, \u0060symbol\u0060, \u0060function\u0060 and \u0060object\u0060. Note that \u0060typeof null\u0060 returns \u0060\u0022object\u0022\u0060."
  },
  {
    "id": "35",
    "question": "Which of these values are falsy?\n\n\u0060\u0060\u0060javascript\n0;\nnew Number(0);\n(\u0027\u0027);\n(\u0027 \u0027);\nnew Boolean(false);\nundefined;\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "0, \u0027\u0027, undefined",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "0, new Number(0), \u0027\u0027, new Boolean(false), undefined",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "0, \u0027\u0027, new Boolean(false), undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "All of them are falsy",
        "isCorrect": false
      }
    ],
    "explanation": "There are 8 falsy values:\n\n- \u0060undefined\u0060\n- \u0060null\u0060\n- \u0060NaN\u0060\n- \u0060false\u0060\n- \u0060\u0027\u0027\u0060 (empty string)\n- \u00600\u0060\n- \u0060-0\u0060\n- \u00600n\u0060 (BigInt(0))\n\nFunction constructors, like \u0060new Number\u0060 and \u0060new Boolean\u0060 are truthy."
  },
  {
    "id": "36",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconsole.log(typeof typeof 1);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022number\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022string\u0022",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "\u0022object\u0022",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "\u0022undefined\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060typeof 1\u0060 returns \u0060\u0022number\u0022\u0060.\n\u0060typeof \u0022number\u0022\u0060 returns \u0060\u0022string\u0022\u0060"
  },
  {
    "id": "37",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst numbers = [1, 2, 3];\nnumbers[10] = 11;\nconsole.log(numbers);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[1, 2, 3, null x 7, 11]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[1, 2, 3, 11]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[1, 2, 3, empty x 7, 11]",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "SyntaxError",
        "isCorrect": false
      }
    ],
    "explanation": "When you set a value to an element in an array that exceeds the length of the array, JavaScript creates something called \u0022empty slots\u0022. These actually have the value of \u0060undefined\u0060, but you will see something like:\n\n\u0060[1, 2, 3, empty x 7, 11]\u0060\n\ndepending on where you run it (it\u0027s different for every browser, node, etc.)"
  },
  {
    "id": "38",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\n(() =\u003E {\n  let x, y;\n  try {\n    throw new Error();\n  } catch (x) {\n    (x = 1), (y = 2);\n    console.log(x);\n  }\n  console.log(x);\n  console.log(y);\n})();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "1 undefined 2",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "undefined undefined undefined",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "1 1 2",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "1 undefined undefined",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060catch\u0060 block receives the argument \u0060x\u0060. This is not the same \u0060x\u0060 as the variable when we pass arguments. This variable \u0060x\u0060 is block-scoped.\n\nLater, we set this block-scoped variable equal to \u00601\u0060, and set the value of the variable \u0060y\u0060. Now, we log the block-scoped variable \u0060x\u0060, which is equal to \u00601\u0060.\n\nOutside of the \u0060catch\u0060 block, \u0060x\u0060 is still \u0060undefined\u0060, and \u0060y\u0060 is \u00602\u0060. When we want to \u0060console.log(x)\u0060 outside of the \u0060catch\u0060 block, it returns \u0060undefined\u0060, and \u0060y\u0060 returns \u00602\u0060."
  },
  {
    "id": "39",
    "question": "Everything in JavaScript is either a...",
    "answers": [
      {
        "index": "A",
        "answer": "primitive or object",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "function or object",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "trick question! only objects",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "number or object",
        "isCorrect": false
      }
    ],
    "explanation": "JavaScript only has primitive types and objects.\n\nPrimitive types are \u0060boolean\u0060, \u0060null\u0060, \u0060undefined\u0060, \u0060bigint\u0060, \u0060number\u0060, \u0060string\u0060, and \u0060symbol\u0060.\n\nWhat differentiates a primitive from an object is that primitives do not have any properties or methods; however, you\u0027ll note that \u0060\u0027foo\u0027.toUpperCase()\u0060 evaluates to \u0060\u0027FOO\u0027\u0060 and does not result in a \u0060TypeError\u0060. This is because when you try to access a property or method on a primitive like a string, JavaScript will implicitly wrap the primitive type using one of the wrapper classes, i.e. \u0060String\u0060, and then immediately discard the wrapper after the expression evaluates. All primitives except for \u0060null\u0060 and \u0060undefined\u0060 exhibit this behaviour."
  },
  {
    "id": "40",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\n[[0, 1], [2, 3]].reduce(\n  (acc, cur) =\u003E {\n    return acc.concat(cur);\n  },\n  [1, 2],\n);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[0, 1, 2, 3, 1, 2]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[6, 1, 2]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[1, 2, 0, 1, 2, 3]",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "[1, 2, 6]",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060[1, 2]\u0060 is our initial value. This is the value we start with, and the value of the very first \u0060acc\u0060. During the first round, \u0060acc\u0060 is \u0060[1,2]\u0060, and \u0060cur\u0060 is \u0060[0, 1]\u0060. We concatenate them, which results in \u0060[1, 2, 0, 1]\u0060.\n\nThen, \u0060[1, 2, 0, 1]\u0060 is \u0060acc\u0060 and \u0060[2, 3]\u0060 is \u0060cur\u0060. We concatenate them, and get \u0060[1, 2, 0, 1, 2, 3]\u0060"
  },
  {
    "id": "41",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\n!!null;\n!!\u0027\u0027;\n!!1;\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "false true false",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "false false true",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "false true true",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "true true false",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060null\u0060 is falsy. \u0060!null\u0060 returns \u0060true\u0060. \u0060!true\u0060 returns \u0060false\u0060.\n\n\u0060\u0022\u0022\u0060 is falsy. \u0060!\u0022\u0022\u0060 returns \u0060true\u0060. \u0060!true\u0060 returns \u0060false\u0060.\n\n\u00601\u0060 is truthy. \u0060!1\u0060 returns \u0060false\u0060. \u0060!false\u0060 returns \u0060true\u0060."
  },
  {
    "id": "42",
    "question": "What does the \u0060setInterval\u0060 method return in the browser?\n\n\u0060\u0060\u0060javascript\nsetInterval(() =\u003E console.log(\u0027Hi\u0027), 1000);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "a unique id",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "the amount of milliseconds specified",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "the passed function",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined",
        "isCorrect": false
      }
    ],
    "explanation": "It returns a unique id. This id can be used to clear that interval with the \u0060clearInterval()\u0060 function."
  },
  {
    "id": "43",
    "question": "What does this return?\n\n\u0060\u0060\u0060javascript\n[...\u0027Lydia\u0027];\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[\u0022L\u0022, \u0022y\u0022, \u0022d\u0022, \u0022i\u0022, \u0022a\u0022]",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "[\u0022Lydia\u0022]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[[], \u0022Lydia\u0022]",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "[[\u0022L\u0022, \u0022y\u0022, \u0022d\u0022, \u0022i\u0022, \u0022a\u0022]]",
        "isCorrect": false
      }
    ],
    "explanation": "A string is an iterable. The spread operator maps every character of an iterable to one element."
  },
  {
    "id": "44",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction* generator(i) {\n  yield i;\n  yield i * 2;\n}\n\nconst gen = generator(10);\n\nconsole.log(gen.next().value);\nconsole.log(gen.next().value);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[0, 10], [10, 20]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "20, 20",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "10, 20",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "0, 10 and 10, 20",
        "isCorrect": false
      }
    ],
    "explanation": "Regular functions cannot be stopped mid-way after invocation. However, a generator function can be \u0022stopped\u0022 midway, and later continue from where it stopped. Every time a generator function encounters a \u0060yield\u0060 keyword, the function yields the value specified after it. Note that the generator function in that case doesn\u2019t _return_ the value, it _yields_ the value.\n\nFirst, we initialize the generator function with \u0060i\u0060 equal to \u006010\u0060. We invoke the generator function using the \u0060next()\u0060 method. The first time we invoke the generator function, \u0060i\u0060 is equal to \u006010\u0060. It encounters the first \u0060yield\u0060 keyword: it yields the value of \u0060i\u0060. The generator is now \u0022paused\u0022, and \u006010\u0060 gets logged.\n\nThen, we invoke the function again with the \u0060next()\u0060 method. It starts to continue where it stopped previously, still with \u0060i\u0060 equal to \u006010\u0060. Now, it encounters the next \u0060yield\u0060 keyword, and yields \u0060i * 2\u0060. \u0060i\u0060 is equal to \u006010\u0060, so it returns \u006010 * 2\u0060, which is \u006020\u0060. This results in \u006010, 20\u0060."
  },
  {
    "id": "45",
    "question": "What does this return?\n\n\u0060\u0060\u0060javascript\nconst firstPromise = new Promise((res, rej) =\u003E {\n  setTimeout(res, 500, \u0027one\u0027);\n});\n\nconst secondPromise = new Promise((res, rej) =\u003E {\n  setTimeout(res, 100, \u0027two\u0027);\n});\n\nPromise.race([firstPromise, secondPromise]).then(res =\u003E console.log(res));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022one\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022two\u0022",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "\u0022two\u0022 \u0022one\u0022",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "\u0022one\u0022 \u0022two\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "When we pass multiple promises to the \u0060Promise.race\u0060 method, it resolves/rejects the _first_ promise that resolves/rejects. To the \u0060setTimeout\u0060 method, we pass a timer: 500ms for the first promise (\u0060firstPromise\u0060), and 100ms for the second promise (\u0060secondPromise\u0060). This means that the \u0060secondPromise\u0060 resolves first with the value of \u0060\u0027two\u0027\u0060. \u0060res\u0060 now holds the value of \u0060\u0027two\u0027\u0060, which gets logged."
  },
  {
    "id": "46",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nlet person = { name: \u0027Lydia\u0027 };\nconst members = [person];\nperson = null;\n\nconsole.log(members);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "null",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[null]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[{}]",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "[{ name: \u0022Lydia\u0022 }]",
        "isCorrect": true
      }
    ],
    "explanation": "First, we declare a variable \u0060person\u0060 with the value of an object that has a \u0060name\u0060 property.\n\n\u003Cimg src=\u0022https://i.imgur.com/TML1MbS.png\u0022 width=\u0022200\u0022\u003E\n\nThen, we declare a variable called \u0060members\u0060. We set the first element of that array equal to the value of the \u0060person\u0060 variable. Objects interact by _reference_ when setting them equal to each other. When you assign a reference from one variable to another, you make a _copy_ of that reference. (note that they don\u0027t have the _same_ reference!)\n\n\u003Cimg src=\u0022https://i.imgur.com/FSG5K3F.png\u0022 width=\u0022300\u0022\u003E\n\nThen, we set the variable \u0060person\u0060 equal to \u0060null\u0060.\n\n\u003Cimg src=\u0022https://i.imgur.com/sYjcsMT.png\u0022 width=\u0022300\u0022\u003E\n\nWe are only modifying the value of the \u0060person\u0060 variable, and not the first element in the array, since that element has a different (copied) reference to the object. The first element in \u0060members\u0060 still holds its reference to the original object. When we log the \u0060members\u0060 array, the first element still holds the value of the object, which gets logged."
  },
  {
    "id": "47",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst person = {\n  name: \u0027Lydia\u0027,\n  age: 21,\n};\n\nfor (const item in person) {\n  console.log(item);\n}\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{ name: \u0022Lydia\u0022 }, { age: 21 }",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022name\u0022, \u0022age\u0022",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "\u0022Lydia\u0022, 21",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "[\u0022name\u0022, \u0022Lydia\u0022], [\u0022age\u0022, 21]",
        "isCorrect": false
      }
    ],
    "explanation": "With a \u0060for-in\u0060 loop, we can iterate through object keys, in this case \u0060name\u0060 and \u0060age\u0060. Under the hood, object keys are strings (if they\u0027re not a Symbol). On every loop, we set the value of \u0060item\u0060 equal to the current key it\u2019s iterating over. First, \u0060item\u0060 is equal to \u0060name\u0060, and gets logged. Then, \u0060item\u0060 is equal to \u0060age\u0060, which gets logged."
  },
  {
    "id": "48",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconsole.log(3 \u002B 4 \u002B \u00275\u0027);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022345\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u002275\u0022",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "12",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "\u002212\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "Operator associativity is the order in which the compiler evaluates the expressions, either left-to-right or right-to-left. This only happens if all operators have the _same_ precedence. We only have one type of operator: \u0060\u002B\u0060. For addition, the associativity is left-to-right.\n\n\u00603 \u002B 4\u0060 gets evaluated first. This results in the number \u00607\u0060.\n\n\u00607 \u002B \u00275\u0027\u0060 results in \u0060\u002275\u0022\u0060 because of coercion. JavaScript converts the number \u00607\u0060 into a string, see question 15. We can concatenate two strings using the \u0060\u002B\u0060operator. \u0060\u00227\u0022 \u002B \u00225\u0022\u0060 results in \u0060\u002275\u0022\u0060."
  },
  {
    "id": "49",
    "question": "What\u0027s the value of \u0060num\u0060?\n\n\u0060\u0060\u0060javascript\nconst num = parseInt(\u00277*6\u0027, 10);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "42",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u002242\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "7",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "NaN",
        "isCorrect": false
      }
    ],
    "explanation": "Only the first numbers in the string is returned. Based on the _radix_ (the second argument in order to specify what type of number we want to parse it to: base 10, hexadecimal, octal, binary, etc.), the \u0060parseInt\u0060 checks whether the characters in the string are valid. Once it encounters a character that isn\u0027t a valid number in the radix, it stops parsing and ignores the following characters.\n\n\u0060*\u0060 is not a valid number. It only parses \u0060\u00227\u0022\u0060 into the decimal \u00607\u0060. \u0060num\u0060 now holds the value of \u00607\u0060."
  },
  {
    "id": "50",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\n[1, 2, 3].map(num =\u003E {\n  if (typeof num === \u0027number\u0027) return;\n  return num * 2;\n});\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[null, null, null]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[undefined, undefined, undefined]",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "[ 3 x empty ]",
        "isCorrect": false
      }
    ],
    "explanation": "When mapping over the array, the value of \u0060num\u0060 is equal to the element it\u2019s currently looping over. In this case, the elements are numbers, so the condition of the if statement \u0060typeof num === \u0022number\u0022\u0060 returns \u0060true\u0060. The map function creates a new array and inserts the values returned from the function.\n\nHowever, we don\u2019t return a value. When we don\u2019t return a value from the function, the function returns \u0060undefined\u0060. For every element in the array, the function block gets called, so for each element we return \u0060undefined\u0060."
  },
  {
    "id": "51",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction getInfo(member, year) {\n  member.name = \u0027Lydia\u0027;\n  year = \u00271998\u0027;\n}\n\nconst person = { name: \u0027Sarah\u0027 };\nconst birthYear = \u00271997\u0027;\n\ngetInfo(person, birthYear);\n\nconsole.log(person, birthYear);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{ name: \u0022Lydia\u0022 }, \u00221997\u0022",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "{ name: \u0022Sarah\u0022 }, \u00221998\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "{ name: \u0022Lydia\u0022 }, \u00221998\u0022",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "{ name: \u0022Sarah\u0022 }, \u00221997\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "Arguments are passed by _value_, unless their value is an object, then they\u0027re passed by _reference_. \u0060birthYear\u0060 is passed by value, since it\u0027s a string, not an object. When we pass arguments by value, a _copy_ of that value is created (see question 46).\n\nThe variable \u0060birthYear\u0060 has a reference to the value \u0060\u00221997\u0022\u0060. The argument \u0060year\u0060 also has a reference to the value \u0060\u00221997\u0022\u0060, but it\u0027s not the same value as \u0060birthYear\u0060 has a reference to. When we update the value of \u0060year\u0060 by setting \u0060year\u0060 equal to \u0060\u00221998\u0022\u0060, we are only updating the value of \u0060year\u0060. \u0060birthYear\u0060 is still equal to \u0060\u00221997\u0022\u0060.\n\nThe value of \u0060person\u0060 is an object. The argument \u0060member\u0060 has a (copied) reference to the _same_ object. When we modify a property of the object \u0060member\u0060 has a reference to, the value of \u0060person\u0060 will also be modified, since they both have a reference to the same object. \u0060person\u0060\u0027s \u0060name\u0060 property is now equal to the value \u0060\u0022Lydia\u0022\u0060"
  },
  {
    "id": "52",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction greeting() {\n  throw \u0027Hello world!\u0027;\n}\n\nfunction sayHi() {\n  try {\n    const data = greeting();\n    console.log(\u0027It worked!\u0027, data);\n  } catch (e) {\n    console.log(\u0027Oh no an error:\u0027, e);\n  }\n}\n\nsayHi();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "It worked! Hello world!",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Oh no an error: undefined",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "SyntaxError: can only throw Error objects",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Oh no an error: Hello world!",
        "isCorrect": true
      }
    ],
    "explanation": "With the \u0060throw\u0060 statement, we can create custom errors. With this statement, you can throw exceptions. An exception can be a \u003Cb\u003Estring\u003C/b\u003E, a \u003Cb\u003Enumber\u003C/b\u003E, a \u003Cb\u003Eboolean\u003C/b\u003E or an \u003Cb\u003Eobject\u003C/b\u003E. In this case, our exception is the string \u0060\u0027Hello world!\u0027\u0060.\n\nWith the \u0060catch\u0060 statement, we can specify what to do if an exception is thrown in the \u0060try\u0060 block. An exception is thrown: the string \u0060\u0027Hello world!\u0027\u0060. \u0060e\u0060 is now equal to that string, which we log. This results in \u0060\u0027Oh an error: Hello world!\u0027\u0060."
  },
  {
    "id": "53",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction Car() {\n  this.make = \u0027Lamborghini\u0027;\n  return { make: \u0027Maserati\u0027 };\n}\n\nconst myCar = new Car();\nconsole.log(myCar.make);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022Lamborghini\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022Maserati\u0022",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "ReferenceError",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "TypeError",
        "isCorrect": false
      }
    ],
    "explanation": "When you return a property, the value of the property is equal to the _returned_ value, not the value set in the constructor function. We return the string \u0060\u0022Maserati\u0022\u0060, so \u0060myCar.make\u0060 is equal to \u0060\u0022Maserati\u0022\u0060."
  },
  {
    "id": "54",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\n(() =\u003E {\n  let x = (y = 10);\n})();\n\nconsole.log(typeof x);\nconsole.log(typeof y);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022undefined\u0022, \u0022number\u0022",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "\u0022number\u0022, \u0022number\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "\u0022object\u0022, \u0022number\u0022",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "\u0022number\u0022, \u0022undefined\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060let x = (y = 10);\u0060 is actually shorthand for:\n\n\u0060\u0060\u0060javascript\ny = 10;\nlet x = y;\n\u0060\u0060\u0060\n\nWhen we set \u0060y\u0060 equal to \u006010\u0060, we actually add a property \u0060y\u0060 to the global object (\u0060window\u0060 in browser, \u0060global\u0060 in Node). In a browser, \u0060window.y\u0060 is now equal to \u006010\u0060.\n\nThen, we declare a variable \u0060x\u0060 with the value of \u0060y\u0060, which is \u006010\u0060. Variables declared with the \u0060let\u0060 keyword are _block scoped_, they are only defined within the block they\u0027re declared in; the immediately invoked function expression (IIFE) in this case. When we use the \u0060typeof\u0060 operator, the operand \u0060x\u0060 is not defined: we are trying to access \u0060x\u0060 outside of the block it\u0027s declared in. This means that \u0060x\u0060 is not defined. Values who haven\u0027t been assigned a value or declared are of type \u0060\u0022undefined\u0022\u0060. \u0060console.log(typeof x)\u0060 returns \u0060\u0022undefined\u0022\u0060.\n\nHowever, we created a global variable \u0060y\u0060 when setting \u0060y\u0060 equal to \u006010\u0060. This value is accessible anywhere in our code. \u0060y\u0060 is defined, and holds a value of type \u0060\u0022number\u0022\u0060. \u0060console.log(typeof y)\u0060 returns \u0060\u0022number\u0022\u0060."
  },
  {
    "id": "55",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nclass Dog {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nDog.prototype.bark = function() {\n  console.log(\u0060Woof I am ${this.name}\u0060);\n};\n\nconst pet = new Dog(\u0027Mara\u0027);\n\npet.bark();\n\ndelete Dog.prototype.bark;\n\npet.bark();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022Woof I am Mara\u0022, TypeError",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "\u0022Woof I am Mara\u0022, \u0022Woof I am Mara\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "\u0022Woof I am Mara\u0022, undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "TypeError, TypeError",
        "isCorrect": false
      }
    ],
    "explanation": "We can delete properties from objects using the \u0060delete\u0060 keyword, also on the prototype. By deleting a property on the prototype, it is not available anymore in the prototype chain. In this case, the \u0060bark\u0060 function is not available anymore on the prototype after \u0060delete Dog.prototype.bark\u0060, yet we still try to access it.\n\nWhen we try to invoke something that is not a function, a \u0060TypeError\u0060 is thrown. In this case \u0060TypeError: pet.bark is not a function\u0060, since \u0060pet.bark\u0060 is \u0060undefined\u0060."
  },
  {
    "id": "56",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst set = new Set([1, 1, 2, 3, 4]);\n\nconsole.log(set);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[1, 1, 2, 3, 4]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[1, 2, 3, 4]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "{1, 1, 2, 3, 4}",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "{1, 2, 3, 4}",
        "isCorrect": true
      }
    ],
    "explanation": "The \u0060Set\u0060 object is a collection of _unique_ values: a value can only occur once in a set.\n\nWe passed the iterable \u0060[1, 1, 2, 3, 4]\u0060 with a duplicate value \u00601\u0060. Since we cannot have two of the same values in a set, one of them is removed. This results in \u0060{1, 2, 3, 4}\u0060."
  },
  {
    "id": "57",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\n// counter.js\nlet counter = 10;\nexport default counter;\n\u0060\u0060\u0060\n\n\u0060\u0060\u0060javascript\n// index.js\nimport myCounter from \u0027./counter\u0027;\n\nmyCounter \u002B= 1;\n\nconsole.log(myCounter);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "10",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "11",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Error",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "NaN",
        "isCorrect": false
      }
    ],
    "explanation": "An imported module is _read-only_: you cannot modify the imported module. Only the module that exports them can change its value.\n\nWhen we try to increment the value of \u0060myCounter\u0060, it throws an error: \u0060myCounter\u0060 is read-only and cannot be modified."
  },
  {
    "id": "58",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst name = \u0027Lydia\u0027;\nage = 21;\n\nconsole.log(delete name);\nconsole.log(delete age);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "false, true",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "\u0022Lydia\u0022, 21",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "true, true",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined, undefined",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060delete\u0060 operator returns a boolean value: \u0060true\u0060 on a successful deletion, else it\u0027ll return \u0060false\u0060. However, variables declared with the \u0060var\u0060, \u0060const\u0060 or \u0060let\u0060 keyword cannot be deleted using the \u0060delete\u0060 operator.\n\nThe \u0060name\u0060 variable was declared with a \u0060const\u0060 keyword, so its deletion is not successful: \u0060false\u0060 is returned. When we set \u0060age\u0060 equal to \u006021\u0060, we actually added a property called \u0060age\u0060 to the global object. You can successfully delete properties from objects this way, also the global object, so \u0060delete age\u0060 returns \u0060true\u0060."
  },
  {
    "id": "59",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst numbers = [1, 2, 3, 4, 5];\nconst [y] = numbers;\n\nconsole.log(y);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[[1, 2, 3, 4, 5]]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[1, 2, 3, 4, 5]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "1",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "[1]",
        "isCorrect": false
      }
    ],
    "explanation": "We can unpack values from arrays or properties from objects through destructuring. For example:\n\n\u0060\u0060\u0060javascript\n[a, b] = [1, 2];\n\u0060\u0060\u0060\n\n\u003Cimg src=\u0022https://i.imgur.com/ADFpVop.png\u0022 width=\u0022200\u0022\u003E\n\nThe value of \u0060a\u0060 is now \u00601\u0060, and the value of \u0060b\u0060 is now \u00602\u0060. What we actually did in the question, is:\n\n\u0060\u0060\u0060javascript\n[y] = [1, 2, 3, 4, 5];\n\u0060\u0060\u0060\n\n\u003Cimg src=\u0022https://i.imgur.com/NzGkMNk.png\u0022 width=\u0022200\u0022\u003E\n\nThis means that the value of \u0060y\u0060 is equal to the first value in the array, which is the number \u00601\u0060. When we log \u0060y\u0060, \u00601\u0060 is returned."
  },
  {
    "id": "60",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst user = { name: \u0027Lydia\u0027, age: 21 };\nconst admin = { admin: true, ...user };\n\nconsole.log(admin);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{ admin: true, user: { name: \u0022Lydia\u0022, age: 21 } }",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "{ admin: true, name: \u0022Lydia\u0022, age: 21 }",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "{ admin: true, user: [\u0022Lydia\u0022, 21] }",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "{ admin: true }",
        "isCorrect": false
      }
    ],
    "explanation": "It\u0027s possible to combine objects using the spread operator \u0060...\u0060. It lets you create copies of the key/value pairs of one object, and add them to another object. In this case, we create copies of the \u0060user\u0060 object, and add them to the \u0060admin\u0060 object. The \u0060admin\u0060 object now contains the copied key/value pairs, which results in \u0060{ admin: true, name: \u0022Lydia\u0022, age: 21 }\u0060."
  },
  {
    "id": "61",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst person = { name: \u0027Lydia\u0027 };\n\nObject.defineProperty(person, \u0027age\u0027, { value: 21 });\n\nconsole.log(person);\nconsole.log(Object.keys(person));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{ name: \u0022Lydia\u0022, age: 21 }, [\u0022name\u0022, \u0022age\u0022]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "{ name: \u0022Lydia\u0022, age: 21 }, [\u0022name\u0022]",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "{ name: \u0022Lydia\u0022}, [\u0022name\u0022, \u0022age\u0022]",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "{ name: \u0022Lydia\u0022}, [\u0022age\u0022]",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060defineProperty\u0060 method, we can add new properties to an object, or modify existing ones. When we add a property to an object using the \u0060defineProperty\u0060 method, they are by default _not enumerable_. The \u0060Object.keys\u0060 method returns all _enumerable_ property names from an object, in this case only \u0060\u0022name\u0022\u0060.\n\nProperties added using the \u0060defineProperty\u0060 method are immutable by default. You can override this behavior using the \u0060writable\u0060, \u0060configurable\u0060 and \u0060enumerable\u0060 properties. This way, the \u0060defineProperty\u0060 method gives you a lot more control over the properties you\u0027re adding to an object."
  },
  {
    "id": "62",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst settings = {\n  username: \u0027lydiahallie\u0027,\n  level: 19,\n  health: 90,\n};\n\nconst data = JSON.stringify(settings, [\u0027level\u0027, \u0027health\u0027]);\nconsole.log(data);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022{\u0022level\u0022:19, \u0022health\u0022:90}\u0022",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "\u0022{\u0022username\u0022: \u0022lydiahallie\u0022}\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "\u0022[\u0022level\u0022, \u0022health\u0022]\u0022",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "\u0022{\u0022username\u0022: \u0022lydiahallie\u0022, \u0022level\u0022:19, \u0022health\u0022:90}\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "The second argument of \u0060JSON.stringify\u0060 is the _replacer_. The replacer can either be a function or an array, and lets you control what and how the values should be stringified.\n\nIf the replacer is an _array_, only the property names included in the array will be added to the JSON string. In this case, only the properties with the names \u0060\u0022level\u0022\u0060 and \u0060\u0022health\u0022\u0060 are included, \u0060\u0022username\u0022\u0060 is excluded. \u0060data\u0060 is now equal to \u0060\u0022{\u0022level\u0022:19, \u0022health\u0022:90}\u0022\u0060.\n\nIf the replacer is a _function_, this function gets called on every property in the object you\u0027re stringifying. The value returned from this function will be the value of the property when it\u0027s added to the JSON string. If the value is \u0060undefined\u0060, this property is excluded from the JSON string."
  },
  {
    "id": "63",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nlet num = 10;\n\nconst increaseNumber = () =\u003E num\u002B\u002B;\nconst increasePassedNumber = number =\u003E number\u002B\u002B;\n\nconst num1 = increaseNumber();\nconst num2 = increasePassedNumber(num1);\n\nconsole.log(num1);\nconsole.log(num2);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "10, 10",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "10, 11",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "11, 11",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "11, 12",
        "isCorrect": false
      }
    ],
    "explanation": "The unary operator \u0060\u002B\u002B\u0060 _first returns_ the value of the operand, _then increments_ the value of the operand. The value of \u0060num1\u0060 is \u006010\u0060, since the \u0060increaseNumber\u0060 function first returns the value of \u0060num\u0060, which is \u006010\u0060, and only increments the value of \u0060num\u0060 afterwards.\n\n\u0060num2\u0060 is \u006010\u0060, since we passed \u0060num1\u0060 to the \u0060increasePassedNumber\u0060. \u0060number\u0060 is equal to \u006010\u0060(the value of \u0060num1\u0060. Again, the unary operator \u0060\u002B\u002B\u0060 _first returns_ the value of the operand, _then increments_ the value of the operand. The value of \u0060number\u0060 is \u006010\u0060, so \u0060num2\u0060 is equal to \u006010\u0060."
  },
  {
    "id": "64",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst value = { number: 10 };\n\nconst multiply = (x = { ...value }) =\u003E {\n  console.log((x.number *= 2));\n};\n\nmultiply();\nmultiply();\nmultiply(value);\nmultiply(value);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "20, 40, 80, 160",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "20, 40, 20, 40",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "20, 20, 20, 40",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "NaN, NaN, 20, 40",
        "isCorrect": false
      }
    ],
    "explanation": "In ES6, we can initialize parameters with a default value. The value of the parameter will be the default value, if no other value has been passed to the function, or if the value of the parameter is \u0060\u0022undefined\u0022\u0060. In this case, we spread the properties of the \u0060value\u0060 object into a new object, so \u0060x\u0060 has the default value of \u0060{ number: 10 }\u0060.\n\nThe default argument is evaluated at _call time_! Every time we call the function, a _new_ object is created. We invoke the \u0060multiply\u0060 function the first two times without passing a value: \u0060x\u0060 has the default value of \u0060{ number: 10 }\u0060. We then log the multiplied value of that number, which is \u006020\u0060.\n\nThe third time we invoke multiply, we do pass an argument: the object called \u0060value\u0060. The \u0060*=\u0060 operator is actually shorthand for \u0060x.number = x.number * 2\u0060: we modify the value of \u0060x.number\u0060, and log the multiplied value \u006020\u0060.\n\nThe fourth time, we pass the \u0060value\u0060 object again. \u0060x.number\u0060 was previously modified to \u006020\u0060, so \u0060x.number *= 2\u0060 logs \u006040\u0060."
  },
  {
    "id": "65",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\n[1, 2, 3, 4].reduce((x, y) =\u003E console.log(x, y));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "1 2 and 3 3 and 6 4",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "1 2 and 2 3 and 3 4",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "1 undefined and 2 undefined and 3 undefined and 4 undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "1 2 and undefined 3 and undefined 4",
        "isCorrect": true
      }
    ],
    "explanation": "The first argument that the \u0060reduce\u0060 method receives is the _accumulator_, \u0060x\u0060 in this case. The second argument is the _current value_, \u0060y\u0060. With the reduce method, we execute a callback function on every element in the array, which could ultimately result in one single value.\n\nIn this example, we are not returning any values, we are simply logging the values of the accumulator and the current value.\n\nThe value of the accumulator is equal to the previously returned value of the callback function. If you don\u0027t pass the optional \u0060initialValue\u0060 argument to the \u0060reduce\u0060 method, the accumulator is equal to the first element on the first call.\n\nOn the first call, the accumulator (\u0060x\u0060) is \u00601\u0060, and the current value (\u0060y\u0060) is \u00602\u0060. We don\u0027t return from the callback function, we log the accumulator and current value: \u00601\u0060 and \u00602\u0060 get logged.\n\nIf you don\u0027t return a value from a function, it returns \u0060undefined\u0060. On the next call, the accumulator is \u0060undefined\u0060, and the current value is \u00603\u0060. \u0060undefined\u0060 and \u00603\u0060 get logged.\n\nOn the fourth call, we again don\u0027t return from the callback function. The accumulator is again \u0060undefined\u0060, and the current value is \u00604\u0060. \u0060undefined\u0060 and \u00604\u0060 get logged."
  },
  {
    "id": "66",
    "question": "With which constructor can we successfully extend the \u0060Dog\u0060 class?\n\n\u0060\u0060\u0060javascript\nclass Dog {\n  constructor(name) {\n    this.name = name;\n  }\n};\n\nclass Labrador extends Dog {\n  // 1\n  constructor(name, size) {\n    this.size = size;\n  }\n  // 2\n  constructor(name, size) {\n    super(name);\n    this.size = size;\n  }\n  // 3\n  constructor(size) {\n    super(name);\n    this.size = size;\n  }\n  // 4\n  constructor(name, size) {\n    this.name = name;\n    this.size = size;\n  }\n\n};\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "1",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "2",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "3",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "4",
        "isCorrect": false
      }
    ],
    "explanation": "In a derived class, you cannot access the \u0060this\u0060 keyword before calling \u0060super\u0060. If you try to do that, it will throw a ReferenceError: 1 and 4 would throw a reference error.\n\nWith the \u0060super\u0060 keyword, we call that parent class\u0027s constructor with the given arguments. The parent\u0027s constructor receives the \u0060name\u0060 argument, so we need to pass \u0060name\u0060 to \u0060super\u0060.\n\nThe \u0060Labrador\u0060 class receives two arguments, \u0060name\u0060 since it extends \u0060Dog\u0060, and \u0060size\u0060 as an extra property on the \u0060Labrador\u0060 class. They both need to be passed to the constructor function on \u0060Labrador\u0060, which is done correctly using constructor 2."
  },
  {
    "id": "67",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\n// index.js\nconsole.log(\u0027running index.js\u0027);\nimport { sum } from \u0027./sum.js\u0027;\nconsole.log(sum(1, 2));\n\n// sum.js\nconsole.log(\u0027running sum.js\u0027);\nexport const sum = (a, b) =\u003E a \u002B b;\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "running index.js, running sum.js, 3",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "running sum.js, running index.js, 3",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "running sum.js, 3, running index.js",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "running index.js, undefined, running sum.js",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060import\u0060 keyword, all imported modules are _pre-parsed_. This means that the imported modules get run _first_, the code in the file which imports the module gets executed _after_.\n\nThis is a difference between \u0060require()\u0060 in CommonJS and \u0060import\u0060! With \u0060require()\u0060, you can load dependencies on demand while the code is being run. If we would have used \u0060require\u0060 instead of \u0060import\u0060, \u0060running index.js\u0060, \u0060running sum.js\u0060, \u00603\u0060 would have been logged to the console."
  },
  {
    "id": "68",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconsole.log(Number(2) === Number(2));\nconsole.log(Boolean(false) === Boolean(false));\nconsole.log(Symbol(\u0027foo\u0027) === Symbol(\u0027foo\u0027));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "true, true, false",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "false, true, false",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "true, false, true",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "true, true, true",
        "isCorrect": false
      }
    ],
    "explanation": "Every Symbol is entirely unique. The purpose of the argument passed to the Symbol is to give the Symbol a description. The value of the Symbol is not dependent on the passed argument. As we test equality, we are creating two entirely new symbols: the first \u0060Symbol(\u0027foo\u0027)\u0060, and the second \u0060Symbol(\u0027foo\u0027)\u0060. These two values are unique and not equal to each other, \u0060Symbol(\u0027foo\u0027) === Symbol(\u0027foo\u0027)\u0060 returns \u0060false\u0060."
  },
  {
    "id": "69",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst name = \u0027Lydia Hallie\u0027;\nconsole.log(name.padStart(13));\nconsole.log(name.padStart(2));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022Lydia Hallie\u0022, \u0022Lydia Hallie\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022 Lydia Hallie\u0022, \u0022 Lydia Hallie\u0022 (\u0022[13x whitespace]Lydia Hallie\u0022, \u0022[2x whitespace]Lydia Hallie\u0022)",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "\u0022 Lydia Hallie\u0022, \u0022Lydia Hallie\u0022 (\u0022[1x whitespace]Lydia Hallie\u0022, \u0022Lydia Hallie\u0022)",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "\u0022Lydia Hallie\u0022, \u0022Lyd\u0022,",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060padStart\u0060 method, we can add padding to the beginning of a string. The value passed to this method is the _total_ length of the string together with the padding. The string \u0060\u0022Lydia Hallie\u0022\u0060 has a length of \u006012\u0060. \u0060name.padStart(13)\u0060 inserts 1 space at the start of the string, because 12 \u002B 1 is 13.\n\nIf the argument passed to the \u0060padStart\u0060 method is smaller than the length of the array, no padding will be added."
  },
  {
    "id": "70",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconsole.log(\u0027\uD83E\uDD51\u0027 \u002B \u0027\uD83D\uDCBB\u0027);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022\uD83E\uDD51\uD83D\uDCBB\u0022",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "257548",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "A string containing their code points",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Error",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060\u002B\u0060 operator, you can concatenate strings. In this case, we are concatenating the string \u0060\u0022\uD83E\uDD51\u0022\u0060 with the string \u0060\u0022\uD83D\uDCBB\u0022\u0060, resulting in \u0060\u0022\uD83E\uDD51\uD83D\uDCBB\u0022\u0060."
  },
  {
    "id": "71",
    "question": "How can we log the values that are commented out after the console.log statement?\n\n\u0060\u0060\u0060javascript\nfunction* startGame() {\n  const answer = yield \u0027Do you love JavaScript?\u0027;\n  if (answer !== \u0027Yes\u0027) {\n    return \u0022Oh wow... Guess we\u0027re done here\u0022;\n  }\n  return \u0027JavaScript loves you back \u2764\uFE0F\u0027;\n}\n\nconst game = startGame();\nconsole.log(/* 1 */); // Do you love JavaScript?\nconsole.log(/* 2 */); // JavaScript loves you back \u2764\uFE0F\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "game.next(\u0022Yes\u0022).value and game.next().value",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "game.next.value(\u0022Yes\u0022) and game.next.value()",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "game.next().value and game.next(\u0022Yes\u0022).value",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "game.next.value() and game.next.value(\u0022Yes\u0022)",
        "isCorrect": false
      }
    ],
    "explanation": "A generator function \u0022pauses\u0022 its execution when it sees the \u0060yield\u0060 keyword. First, we have to let the function yield the string \u0022Do you love JavaScript?\u0022, which can be done by calling \u0060game.next().value\u0060.\n\nEvery line is executed, until it finds the first \u0060yield\u0060 keyword. There is a \u0060yield\u0060 keyword on the first line within the function: the execution stops with the first yield! _This means that the variable \u0060answer\u0060 is not defined yet!_\n\nWhen we call \u0060game.next(\u0022Yes\u0022).value\u0060, the previous \u0060yield\u0060 is replaced with the value of the parameters passed to the \u0060next()\u0060 function, \u0060\u0022Yes\u0022\u0060 in this case. The value of the variable \u0060answer\u0060 is now equal to \u0060\u0022Yes\u0022\u0060. The condition of the if-statement returns \u0060false\u0060, and \u0060JavaScript loves you back \u2764\uFE0F\u0060 gets logged."
  },
  {
    "id": "72",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconsole.log(String.raw\u0060Hello\\nworld\u0060);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Hello world!",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Hello \u003Cbr /\u003E\u0026nbsp; \u0026nbsp; \u0026nbsp;world",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Hello\\nworld",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "Hello\\n \u003Cbr /\u003E \u0026nbsp; \u0026nbsp; \u0026nbsp;world",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060String.raw\u0060 returns a string where the escapes (\u0060\\n\u0060, \u0060\\v\u0060, \u0060\\t\u0060 etc.) are ignored! Backslashes can be an issue since you could end up with something like:\n\n\u0060\u0060 const path = \u0060C:\\Documents\\Projects\\table.html\u0060 \u0060\u0060\n\nWhich would result in:\n\n\u0060\u0022C:DocumentsProjects able.html\u0022\u0060\n\nWith \u0060String.raw\u0060, it would simply ignore the escape and print:\n\n\u0060C:\\Documents\\Projects\\table.html\u0060\n\nIn this case, the string is \u0060Hello\\nworld\u0060, which gets logged."
  },
  {
    "id": "73",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nasync function getData() {\n  return await Promise.resolve(\u0027I made it!\u0027);\n}\n\nconst data = getData();\nconsole.log(data);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022I made it!\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Promise {\u003Cresolved\u003E: \u0022I made it!\u0022}",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Promise {\u003Cpending\u003E}",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "undefined",
        "isCorrect": false
      }
    ],
    "explanation": "An async function always returns a promise. The \u0060await\u0060 still has to wait for the promise to resolve: a pending promise gets returned when we call \u0060getData()\u0060 in order to set \u0060data\u0060 equal to it.\n\nIf we wanted to get access to the resolved value \u0060\u0022I made it\u0022\u0060, we could have used the \u0060.then()\u0060 method on \u0060data\u0060:\n\n\u0060data.then(res =\u003E console.log(res))\u0060\n\nThis would\u0027ve logged \u0060\u0022I made it!\u0022\u0060"
  },
  {
    "id": "74",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction addToList(item, list) {\n  return list.push(item);\n}\n\nconst result = addToList(\u0027apple\u0027, [\u0027banana\u0027]);\nconsole.log(result);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[\u0027apple\u0027, \u0027banana\u0027]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "2",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "true",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060.push()\u0060 method returns the _length_ of the new array! Previously, the array contained one element (the string \u0060\u0022banana\u0022\u0060) and had a length of \u00601\u0060. After adding the string \u0060\u0022apple\u0022\u0060 to the array, the array contains two elements, and has a length of \u00602\u0060. This gets returned from the \u0060addToList\u0060 function.\n\nThe \u0060push\u0060 method modifies the original array. If you wanted to return the _array_ from the function rather than the _length of the array_, you should have returned \u0060list\u0060 after pushing \u0060item\u0060 to it."
  },
  {
    "id": "75",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst box = { x: 10, y: 20 };\n\nObject.freeze(box);\n\nconst shape = box;\nshape.x = 100;\n\nconsole.log(shape);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{ x: 100, y: 20 }",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "{ x: 10, y: 20 }",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "{ x: 100 }",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060Object.freeze\u0060 makes it impossible to add, remove, or modify properties of an object (unless the property\u0027s value is another object).\n\nWhen we create the variable \u0060shape\u0060 and set it equal to the frozen object \u0060box\u0060, \u0060shape\u0060 also refers to a frozen object. You can check whether an object is frozen by using \u0060Object.isFrozen\u0060. In this case, \u0060Object.isFrozen(shape)\u0060 would return true, since the variable \u0060shape\u0060 has a reference to a frozen object.\n\nSince \u0060shape\u0060 is frozen, and since the value of \u0060x\u0060 is not an object, we cannot modify the property \u0060x\u0060. \u0060x\u0060 is still equal to \u006010\u0060, and \u0060{ x: 10, y: 20 }\u0060 gets logged."
  },
  {
    "id": "76",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst { name: myName } = { name: \u0027Lydia\u0027 };\n\nconsole.log(name);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022Lydia\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022myName\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "When we unpack the property \u0060name\u0060 from the object on the right-hand side, we assign its value \u0060\u0022Lydia\u0022\u0060 to a variable with the name \u0060myName\u0060.\n\nWith \u0060{ name: myName }\u0060, we tell JavaScript that we want to create a new variable called \u0060myName\u0060 with the value of the \u0060name\u0060 property on the right-hand side.\n\nSince we try to log \u0060name\u0060, a variable that is not defined, \u0060undefined\u0060 is returned on the left side assignment. Later, the value of \u0060Lydia\u0060 is stored through the destructuring  assignment."
  },
  {
    "id": "77",
    "question": "Is this a pure function?\n\n\u0060\u0060\u0060javascript\nfunction sum(a, b) {\n  return a \u002B b;\n}\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Yes",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "No",
        "isCorrect": false
      }
    ],
    "explanation": "A pure function is a function that _always_ returns the same result, if the same arguments are passed.\n\nThe \u0060sum\u0060 function always returns the same result. If we pass \u00601\u0060 and \u00602\u0060, it will _always_ return \u00603\u0060 without side effects. If we pass \u00605\u0060 and \u006010\u0060, it will _always_ return \u006015\u0060, and so on. This is the definition of a pure function."
  },
  {
    "id": "78",
    "question": "What is the output?\n\n\u0060\u0060\u0060javascript\nconst add = () =\u003E {\n  const cache = {};\n  return num =\u003E {\n    if (num in cache) {\n      return \u0060From cache! ${cache[num]}\u0060;\n    } else {\n      const result = num \u002B 10;\n      cache[num] = result;\n      return \u0060Calculated! ${result}\u0060;\n    }\n  };\n};\n\nconst addFunction = add();\nconsole.log(addFunction(10));\nconsole.log(addFunction(10));\nconsole.log(addFunction(5 * 2));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Calculated! 20 Calculated! 20 Calculated! 20",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Calculated! 20 From cache! 20 Calculated! 20",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Calculated! 20 From cache! 20 From cache! 20",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "Calculated! 20 From cache! 20 Error",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060add\u0060 function is a _memoized_ function. With memoization, we can cache the results of a function in order to speed up its execution. In this case, we create a \u0060cache\u0060 object that stores the previously returned values.\n\nIf we call the \u0060addFunction\u0060 function again with the same argument, it first checks whether it has already gotten that value in its cache. If that\u0027s the case, the caches value will be returned, which saves on execution time. Else, if it\u0027s not cached, it will calculate the value and store it afterwards.\n\nWe call the \u0060addFunction\u0060 function three times with the same value: on the first invocation, the value of the function when \u0060num\u0060 is equal to \u006010\u0060 isn\u0027t cached yet. The condition of the if-statement \u0060num in cache\u0060 returns \u0060false\u0060, and the else block gets executed: \u0060Calculated! 20\u0060 gets logged, and the value of the result gets added to the cache object. \u0060cache\u0060 now looks like \u0060{ 10: 20 }\u0060.\n\nThe second time, the \u0060cache\u0060 object contains the value that gets returned for \u006010\u0060. The condition of the if-statement \u0060num in cache\u0060 returns \u0060true\u0060, and \u0060\u0027From cache! 20\u0027\u0060 gets logged.\n\nThe third time, we pass \u00605 * 2\u0060 to the function which gets evaluated to \u006010\u0060. The \u0060cache\u0060 object contains the value that gets returned for \u006010\u0060. The condition of the if-statement \u0060num in cache\u0060 returns \u0060true\u0060, and \u0060\u0027From cache! 20\u0027\u0060 gets logged."
  },
  {
    "id": "79",
    "question": "What is the output?\n\n\u0060\u0060\u0060javascript\nconst myLifeSummedUp = [\u0027\u2615\u0027, \u0027\uD83D\uDCBB\u0027, \u0027\uD83C\uDF77\u0027, \u0027\uD83C\uDF6B\u0027];\n\nfor (let item in myLifeSummedUp) {\n  console.log(item);\n}\n\nfor (let item of myLifeSummedUp) {\n  console.log(item);\n}\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "0 1 2 3 and \u0022\u2615\u0022 \u0022\uD83D\uDCBB\u0022 \u0022\uD83C\uDF77\u0022 \u0022\uD83C\uDF6B\u0022",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "\u0022\u2615\u0022 \u0022\uD83D\uDCBB\u0022 \u0022\uD83C\uDF77\u0022 \u0022\uD83C\uDF6B\u0022 and \u0022\u2615\u0022 \u0022\uD83D\uDCBB\u0022 \u0022\uD83C\uDF77\u0022 \u0022\uD83C\uDF6B\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "\u0022\u2615\u0022 \u0022\uD83D\uDCBB\u0022 \u0022\uD83C\uDF77\u0022 \u0022\uD83C\uDF6B\u0022 and 0 1 2 3",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "0 1 2 3 and {0: \u0022\u2615\u0022, 1: \u0022\uD83D\uDCBB\u0022, 2: \u0022\uD83C\uDF77\u0022, 3: \u0022\uD83C\uDF6B\u0022}",
        "isCorrect": false
      }
    ],
    "explanation": "With a _for-in_ loop, we can iterate over **enumerable** properties. In an array, the enumerable properties are the \u0022keys\u0022 of array elements, which are actually their indexes. You could see an array as:\n\n\u0060{0: \u0022\u2615\u0022, 1: \u0022\uD83D\uDCBB\u0022, 2: \u0022\uD83C\uDF77\u0022, 3: \u0022\uD83C\uDF6B\u0022}\u0060\n\nWhere the keys are the enumerable properties. \u00600\u0060 \u00601\u0060 \u00602\u0060 \u00603\u0060 get logged.\n\nWith a _for-of_ loop, we can iterate over **iterables**. An array is an iterable. When we iterate over the array, the variable \u0022item\u0022 is equal to the element it\u0027s currently iterating over, \u0060\u0022\u2615\u0022\u0060 \u0060\u0022\uD83D\uDCBB\u0022\u0060 \u0060\u0022\uD83C\uDF77\u0022\u0060 \u0060\u0022\uD83C\uDF6B\u0022\u0060 get logged."
  },
  {
    "id": "80",
    "question": "What is the output?\n\n\u0060\u0060\u0060javascript\nconst list = [1 \u002B 2, 1 * 2, 1 / 2];\nconsole.log(list);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[\u00221 \u002B 2\u0022, \u00221 * 2\u0022, \u00221 / 2\u0022]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[\u002212\u0022, 2, 0.5]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[3, 2, 0.5]",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "[1, 1, 1]",
        "isCorrect": false
      }
    ],
    "explanation": "Array elements can hold any value. Numbers, strings, objects, other arrays, null, boolean values, undefined, and other expressions such as dates, functions, and calculations.\n\nThe element will be equal to the returned value. \u00601 \u002B 2\u0060 returns \u00603\u0060, \u00601 * 2\u0060 returns \u00602\u0060, and \u00601 / 2\u0060 returns \u00600.5\u0060."
  },
  {
    "id": "81",
    "question": "What is the output?\n\n\u0060\u0060\u0060javascript\nfunction sayHi(name) {\n  return \u0060Hi there, ${name}\u0060;\n}\n\nconsole.log(sayHi());\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Hi there,",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Hi there, undefined",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "Hi there, null",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "By default, arguments have the value of \u0060undefined\u0060, unless a value has been passed to the function. In this case, we didn\u0027t pass a value for the \u0060name\u0060 argument. \u0060name\u0060 is equal to \u0060undefined\u0060 which gets logged.\n\nIn ES6, we can overwrite this default \u0060undefined\u0060 value with default parameters. For example:\n\n\u0060function sayHi(name = \u0022Lydia\u0022) { ... }\u0060\n\nIn this case, if we didn\u0027t pass a value or if we passed \u0060undefined\u0060, \u0060name\u0060 would always be equal to the string \u0060Lydia\u0060"
  },
  {
    "id": "82",
    "question": "What is the output?\n\n\u0060\u0060\u0060javascript\nvar status = \u0027\uD83D\uDE0E\u0027;\n\nsetTimeout(() =\u003E {\n  const status = \u0027\uD83D\uDE0D\u0027;\n\n  const data = {\n    status: \u0027\uD83E\uDD51\u0027,\n    getStatus() {\n      return this.status;\n    },\n  };\n\n  console.log(data.getStatus());\n  console.log(data.getStatus.call(this));\n}, 0);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022\uD83E\uDD51\u0022 and \u0022\uD83D\uDE0D\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022\uD83E\uDD51\u0022 and \u0022\uD83D\uDE0E\u0022",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "\u0022\uD83D\uDE0D\u0022 and \u0022\uD83D\uDE0E\u0022",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "\u0022\uD83D\uDE0E\u0022 and \u0022\uD83D\uDE0E\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "The value of the \u0060this\u0060 keyword is dependent on where you use it. In a **method**, like the \u0060getStatus\u0060 method, the \u0060this\u0060 keyword refers to _the object that the method belongs to_. The method belongs to the \u0060data\u0060 object, so \u0060this\u0060 refers to the \u0060data\u0060 object. When we log \u0060this.status\u0060, the \u0060status\u0060 property on the \u0060data\u0060 object gets logged, which is \u0060\u0022\uD83E\uDD51\u0022\u0060.\n\nWith the \u0060call\u0060 method, we can change the object to which the \u0060this\u0060 keyword refers. In **functions**, the \u0060this\u0060 keyword refers to the _the object that the function belongs to_. We declared the \u0060setTimeout\u0060 function on the _global object_, so within the \u0060setTimeout\u0060 function, the \u0060this\u0060 keyword refers to the _global object_. On the global object, there is a variable called _status_ with the value of \u0060\u0022\uD83D\uDE0E\u0022\u0060. When logging \u0060this.status\u0060, \u0060\u0022\uD83D\uDE0E\u0022\u0060 gets logged."
  },
  {
    "id": "83",
    "question": "What is the output?\n\n\u0060\u0060\u0060javascript\nconst person = {\n  name: \u0027Lydia\u0027,\n  age: 21,\n};\n\nlet city = person.city;\ncity = \u0027Amsterdam\u0027;\n\nconsole.log(person);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{ name: \u0022Lydia\u0022, age: 21 }",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "{ name: \u0022Lydia\u0022, age: 21, city: \u0022Amsterdam\u0022 }",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "{ name: \u0022Lydia\u0022, age: 21, city: undefined }",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "\u0022Amsterdam\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "We set the variable \u0060city\u0060 equal to the value of the property called \u0060city\u0060 on the \u0060person\u0060 object. There is no property on this object called \u0060city\u0060, so the variable \u0060city\u0060 has the value of \u0060undefined\u0060.\n\nNote that we are _not_ referencing the \u0060person\u0060 object itself! We simply set the variable \u0060city\u0060 equal to the current value of the \u0060city\u0060 property on the \u0060person\u0060 object.\n\nThen, we set \u0060city\u0060 equal to the string \u0060\u0022Amsterdam\u0022\u0060. This doesn\u0027t change the person object: there is no reference to that object.\n\nWhen logging the \u0060person\u0060 object, the unmodified object gets returned."
  },
  {
    "id": "84",
    "question": "What is the output?\n\n\u0060\u0060\u0060javascript\nfunction checkAge(age) {\n  if (age \u003C 18) {\n    const message = \u0022Sorry, you\u0027re too young.\u0022;\n  } else {\n    const message = \u0022Yay! You\u0027re old enough!\u0022;\n  }\n\n  return message;\n}\n\nconsole.log(checkAge(21));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022Sorry, you\u0027re too young.\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022Yay! You\u0027re old enough!\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "ReferenceError",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "undefined",
        "isCorrect": false
      }
    ],
    "explanation": "Variables with the \u0060const\u0060 and \u0060let\u0060 keyword are _block-scoped_. A block is anything between curly brackets (\u0060{ }\u0060). In this case, the curly brackets of the if/else statements. You cannot reference a variable outside of the block it\u0027s declared in, a ReferenceError gets thrown."
  },
  {
    "id": "85",
    "question": "What kind of information would get logged?\n\n\u0060\u0060\u0060javascript\nfetch(\u0027https://www.website.com/api/user/1\u0027)\n  .then(res =\u003E res.json())\n  .then(res =\u003E console.log(res));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "The result of the fetch method.",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "The result of the second invocation of the fetch method.",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "The result of the callback in the previous .then().",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "It would always be undefined.",
        "isCorrect": false
      }
    ],
    "explanation": "The value of \u0060res\u0060 in the second \u0060.then\u0060 is equal to the returned value of the previous \u0060.then\u0060. You can keep chaining \u0060.then\u0060s like this, where the value is passed to the next handler."
  },
  {
    "id": "86",
    "question": "Which option is a way to set \u0060hasName\u0060 equal to \u0060true\u0060, provided you cannot pass \u0060true\u0060 as an argument?\n\n\u0060\u0060\u0060javascript\nfunction getName(name) {\n  const hasName = //\n}\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "!!name",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "name",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "new Boolean(name)",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "name.length",
        "isCorrect": false
      }
    ],
    "explanation": "With \u0060!!name\u0060, we determine whether the value of \u0060name\u0060 is truthy or falsy. If name is truthy, which we want to test for, \u0060!name\u0060 returns \u0060false\u0060. \u0060!false\u0060 (which is what \u0060!!name\u0060 practically is) returns \u0060true\u0060.\n\nBy setting \u0060hasName\u0060 equal to \u0060name\u0060, you set \u0060hasName\u0060 equal to whatever value you passed to the \u0060getName\u0060 function, not the boolean value \u0060true\u0060.\n\n\u0060new Boolean(true)\u0060 returns an object wrapper, not the boolean value itself.\n\n\u0060name.length\u0060 returns the length of the passed argument, not whether it\u0027s \u0060true\u0060."
  },
  {
    "id": "87",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconsole.log(\u0027I want pizza\u0027[0]);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022\u0022\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022I\u0022",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "SyntaxError",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined",
        "isCorrect": false
      }
    ],
    "explanation": "In order to get a character at a specific index of a string, you can use bracket notation. The first character in the string has index 0, and so on. In this case, we want to get the element with index 0, the character \u0060\u0022I\u0027\u0060, which gets logged.\n\nNote that this method is not supported in IE7 and below. In that case, use \u0060.charAt()\u0060."
  },
  {
    "id": "88",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction sum(num1, num2 = num1) {\n  console.log(num1 \u002B num2);\n}\n\nsum(10);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "NaN",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "20",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "ReferenceError",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined",
        "isCorrect": false
      }
    ],
    "explanation": "You can set a default parameter\u0027s value equal to another parameter of the function, as long as they\u0027ve been defined _before_ the default parameter. We pass the value \u006010\u0060 to the \u0060sum\u0060 function. If the \u0060sum\u0060 function only receives 1 argument, it means that the value for \u0060num2\u0060 is not passed, and the value of \u0060num1\u0060 is equal to the passed value \u006010\u0060 in this case. The default value of \u0060num2\u0060 is the value of \u0060num1\u0060, which is \u006010\u0060. \u0060num1 \u002B num2\u0060 returns \u006020\u0060.\n\nIf you\u0027re trying to set a default parameter\u0027s value equal to a parameter which is defined _after_ (to the right), the parameter\u0027s value hasn\u0027t been initialized yet, which will throw an error."
  },
  {
    "id": "89",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\n// module.js\nexport default () =\u003E \u0027Hello world\u0027;\nexport const name = \u0027Lydia\u0027;\n\n// index.js\nimport * as data from \u0027./module\u0027;\n\nconsole.log(data);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{ default: function default(), name: \u0022Lydia\u0022 }",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "{ default: function default() }",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "{ default: \u0022Hello world\u0022, name: \u0022Lydia\u0022 }",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Global object of module.js",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060import * as name\u0060 syntax, we import _all exports_ from the \u0060module.js\u0060 file into the \u0060index.js\u0060 file as a new object called \u0060data\u0060 is created. In the \u0060module.js\u0060 file, there are two exports: the default export, and a named export. The default export is a function which returns the string \u0060\u0022Hello World\u0022\u0060, and the named export is a variable called \u0060name\u0060 which has the value of the string \u0060\u0022Lydia\u0022\u0060.\n\nThe \u0060data\u0060 object has a \u0060default\u0060 property for the default export, other properties have the names of the named exports and their corresponding values."
  },
  {
    "id": "90",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nconst member = new Person(\u0027John\u0027);\nconsole.log(typeof member);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022class\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022function\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "\u0022object\u0022",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "\u0022string\u0022",
        "isCorrect": false
      }
    ],
    "explanation": "Classes are syntactical sugar for function constructors. The equivalent of the \u0060Person\u0060 class as a function constructor would be:\n\n\u0060\u0060\u0060javascript\nfunction Person(name) {\n  this.name = name;\n}\n\u0060\u0060\u0060\n\nCalling a function constructor with \u0060new\u0060 results in the creation of an instance of \u0060Person\u0060, \u0060typeof\u0060 keyword returns \u0060\u0022object\u0022\u0060 for an instance. \u0060typeof member\u0060 returns \u0060\u0022object\u0022\u0060."
  },
  {
    "id": "91",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nlet newList = [1, 2, 3].push(4);\n\nconsole.log(newList.push(5));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[1, 2, 3, 4, 5]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[1, 2, 3, 5]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[1, 2, 3, 4]",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Error",
        "isCorrect": true
      }
    ],
    "explanation": "The \u0060.push\u0060 method returns the _new length_ of the array, not the array itself! By setting \u0060newList\u0060 equal to \u0060[1, 2, 3].push(4)\u0060, we set \u0060newList\u0060 equal to the new length of the array: \u00604\u0060.\n\nThen, we try to use the \u0060.push\u0060 method on \u0060newList\u0060. Since \u0060newList\u0060 is the numerical value \u00604\u0060, we cannot use the \u0060.push\u0060 method: a TypeError is thrown."
  },
  {
    "id": "92",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction giveLydiaPizza() {\n  return \u0027Here is pizza!\u0027;\n}\n\nconst giveLydiaChocolate = () =\u003E\n  \u0022Here\u0027s chocolate... now go hit the gym already.\u0022;\n\nconsole.log(giveLydiaPizza.prototype);\nconsole.log(giveLydiaChocolate.prototype);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{ constructor: ...} { constructor: ...}",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "{} { constructor: ...}",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "{ constructor: ...} {}",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "{ constructor: ...} undefined",
        "isCorrect": true
      }
    ],
    "explanation": "Regular functions, such as the \u0060giveLydiaPizza\u0060 function, have a \u0060prototype\u0060 property, which is an object (prototype object) with a \u0060constructor\u0060 property. Arrow functions however, such as the \u0060giveLydiaChocolate\u0060 function, do not have this \u0060prototype\u0060 property. \u0060undefined\u0060 gets returned when trying to access the \u0060prototype\u0060 property using \u0060giveLydiaChocolate.prototype\u0060."
  },
  {
    "id": "93",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst person = {\n  name: \u0027Lydia\u0027,\n  age: 21,\n};\n\nfor (const [x, y] of Object.entries(person)) {\n  console.log(x, y);\n}\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "name Lydia and age 21",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "[\u0022name\u0022, \u0022Lydia\u0022] and [\u0022age\u0022, 21]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[\u0022name\u0022, \u0022age\u0022] and undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Error",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060Object.entries(person)\u0060 returns an array of nested arrays, containing the keys and objects:\n\n\u0060[ [ \u0027name\u0027, \u0027Lydia\u0027 ], [ \u0027age\u0027, 21 ] ]\u0060\n\nUsing the \u0060for-of\u0060 loop, we can iterate over each element in the array, the subarrays in this case. We can destructure the subarrays instantly in the for-of loop, using \u0060const [x, y]\u0060. \u0060x\u0060 is equal to the first element in the subarray, \u0060y\u0060 is equal to the second element in the subarray.\n\nThe first subarray is \u0060[ \u0022name\u0022, \u0022Lydia\u0022 ]\u0060, with \u0060x\u0060 equal to \u0060\u0022name\u0022\u0060, and \u0060y\u0060 equal to \u0060\u0022Lydia\u0022\u0060, which get logged.\nThe second subarray is \u0060[ \u0022age\u0022, 21 ]\u0060, with \u0060x\u0060 equal to \u0060\u0022age\u0022\u0060, and \u0060y\u0060 equal to \u006021\u0060, which get logged."
  },
  {
    "id": "94",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction getItems(fruitList, ...args, favoriteFruit) {\n  return [...fruitList, ...args, favoriteFruit]\n}\n\ngetItems([\u0022banana\u0022, \u0022apple\u0022], \u0022pear\u0022, \u0022orange\u0022)\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[\u0022banana\u0022, \u0022apple\u0022, \u0022pear\u0022, \u0022orange\u0022]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[[\u0022banana\u0022, \u0022apple\u0022], \u0022pear\u0022, \u0022orange\u0022]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[\u0022banana\u0022, \u0022apple\u0022, [\u0022pear\u0022], \u0022orange\u0022]",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "SyntaxError",
        "isCorrect": true
      }
    ],
    "explanation": "\u0060...args\u0060 is a rest parameter. The rest parameter\u0027s value is an array containing all remaining arguments, **and can only be the last parameter**! In this example, the rest parameter was the second parameter. This is not possible, and will throw a syntax error.\n\n\u0060\u0060\u0060javascript\nfunction getItems(fruitList, favoriteFruit, ...args) {\n  return [...fruitList, ...args, favoriteFruit];\n}\n\ngetItems([\u0027banana\u0027, \u0027apple\u0027], \u0027pear\u0027, \u0027orange\u0027);\n\u0060\u0060\u0060\n\nThe above example works. This returns the array \u0060[ \u0027banana\u0027, \u0027apple\u0027, \u0027orange\u0027, \u0027pear\u0027 ]\u0060"
  },
  {
    "id": "95",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction nums(a, b) {\n  if (a \u003E b) console.log(\u0027a is bigger\u0027);\n  else console.log(\u0027b is bigger\u0027);\n  return\n  a \u002B b;\n}\n\nconsole.log(nums(4, 2));\nconsole.log(nums(1, 2));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "a is bigger, 6 and b is bigger, 3",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "a is bigger, undefined and b is bigger, undefined",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "undefined and undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "SyntaxError",
        "isCorrect": false
      }
    ],
    "explanation": "In JavaScript, we don\u0027t _have_ to write the semicolon (\u0060;\u0060) explicitly, however the JavaScript engine still adds them after statements. This is called **Automatic Semicolon Insertion**. A statement can for example be variables, or keywords like \u0060throw\u0060, \u0060return\u0060, \u0060break\u0060, etc.\n\nHere, we wrote a \u0060return\u0060 statement, and another value \u0060a \u002B b\u0060 on a _new line_. However, since it\u0027s a new line, the engine doesn\u0027t know that it\u0027s actually the value that we wanted to return. Instead, it automatically added a semicolon after \u0060return\u0060. You could see this as:\n\n\u0060\u0060\u0060javascript\nreturn;\na \u002B b;\n\u0060\u0060\u0060\n\nThis means that \u0060a \u002B b\u0060 is never reached, since a function stops running after the \u0060return\u0060 keyword. If no value gets returned, like here, the function returns \u0060undefined\u0060. Note that there is no automatic insertion after \u0060if/else\u0060 statements!"
  },
  {
    "id": "96",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nclass Person {\n  constructor() {\n    this.name = \u0027Lydia\u0027;\n  }\n}\n\nPerson = class AnotherPerson {\n  constructor() {\n    this.name = \u0027Sarah\u0027;\n  }\n};\n\nconst member = new Person();\nconsole.log(member.name);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022Lydia\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022Sarah\u0022",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "Error: cannot redeclare Person",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "SyntaxError",
        "isCorrect": false
      }
    ],
    "explanation": "We can set classes equal to other classes/function constructors. In this case, we set \u0060Person\u0060 equal to \u0060AnotherPerson\u0060. The name on this constructor is \u0060Sarah\u0060, so the name property on the new \u0060Person\u0060 instance \u0060member\u0060 is \u0060\u0022Sarah\u0022\u0060."
  },
  {
    "id": "97",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst info = {\n  [Symbol(\u0027a\u0027)]: \u0027b\u0027,\n};\n\nconsole.log(info);\nconsole.log(Object.keys(info));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{Symbol(\u0027a\u0027): \u0027b\u0027} and [\u0022{Symbol(\u0027a\u0027)\u0022]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "{} and []",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "{ a: \u0022b\u0022 } and [\u0022a\u0022]",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "{Symbol(\u0027a\u0027): \u0027b\u0027} and []",
        "isCorrect": true
      }
    ],
    "explanation": "A Symbol is not _enumerable_. The Object.keys method returns all _enumerable_ key properties on an object. The Symbol won\u0027t be visible, and an empty array is returned. When logging the entire object, all properties will be visible, even non-enumerable ones.\n\nThis is one of the many qualities of a symbol: besides representing an entirely unique value (which prevents accidental name collision on objects, for example when working with 2 libraries that want to add properties to the same object), you can also \u0022hide\u0022 properties on objects this way (although not entirely. You can still access symbols using the \u0060Object.getOwnPropertySymbols()\u0060 method)."
  },
  {
    "id": "98",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst getList = ([x, ...y]) =\u003E [x, y]\nconst getUser = user =\u003E { name: user.name, age: user.age }\n\nconst list = [1, 2, 3, 4]\nconst user = { name: \u0022Lydia\u0022, age: 21 }\n\nconsole.log(getList(list))\nconsole.log(getUser(user))\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[1, [2, 3, 4]] and SyntaxError",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "[1, [2, 3, 4]] and { name: \u0022Lydia\u0022, age: 21 }",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[1, 2, 3, 4] and { name: \u0022Lydia\u0022, age: 21 }",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Error and { name: \u0022Lydia\u0022, age: 21 }",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060getList\u0060 function receives an array as its argument. Between the parentheses of the \u0060getList\u0060 function, we destructure this array right away. You could see this as:\n\n\u0060[x, ...y] = [1, 2, 3, 4]\u0060\n\nWith the rest parameter \u0060...y\u0060, we put all \u0022remaining\u0022 arguments in an array. The remaining arguments are \u00602\u0060, \u00603\u0060 and \u00604\u0060 in this case. The value of \u0060y\u0060 is an array, containing all the rest parameters. The value of \u0060x\u0060 is equal to \u00601\u0060 in this case, so when we log \u0060[x, y]\u0060, \u0060[1, [2, 3, 4]]\u0060 gets logged.\n\nThe \u0060getUser\u0060 function receives an object. With arrow functions, we don\u0027t _have_ to write curly brackets if we just return one value. However, if you want to instantly return an _object_ from an arrow function, you have to write it between parentheses, otherwise everything between the two braces will be interpreted as a block statement. In this case the code between the braces is not a valid JavaScript code, so a \u0060SyntaxError\u0060 gets thrown. \n\nThe following function would have returned an object:\n\n\u0060const getUser = user =\u003E ({ name: user.name, age: user.age })\u0060"
  },
  {
    "id": "99",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst name = \u0027Lydia\u0027;\n\nconsole.log(name());\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "SyntaxError",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "ReferenceError",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "TypeError",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "undefined",
        "isCorrect": false
      }
    ],
    "explanation": "The variable \u0060name\u0060 holds the value of a string, which is not a function, thus cannot invoke.\n\nTypeErrors get thrown when a value is not of the expected type. JavaScript expected \u0060name\u0060 to be a function since we\u0027re trying to invoke it. It was a string however, so a TypeError gets thrown: name is not a function!\n\nSyntaxErrors get thrown when you\u0027ve written something that isn\u0027t valid JavaScript, for example when you\u0027ve written the word \u0060return\u0060 as \u0060retrun\u0060.\nReferenceErrors get thrown when JavaScript isn\u0027t able to find a reference to a value that you\u0027re trying to access."
  },
  {
    "id": "100",
    "question": "What\u0027s the value of output?\n\n\u0060\u0060\u0060javascript\n// \uD83C\uDF89\u2728 This is my 100th question! \u2728\uD83C\uDF89\n\nconst output = \u0060${[] \u0026\u0026 \u0027Im\u0027}possible!\nYou should${\u0027\u0027 \u0026\u0026 \u0060n\u0027t\u0060} see a therapist after so much JavaScript lol\u0060;\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "possible! You should see a therapist after so much JavaScript lol",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Impossible! You should see a therapist after so much JavaScript lol",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "possible! You shouldn\u0027t see a therapist after so much JavaScript lol",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Impossible! You shouldn\u0027t see a therapist after so much JavaScript lol",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060[]\u0060 is a truthy value. With the \u0060\u0026\u0026\u0060 operator, the right-hand value will be returned if the left-hand value is a truthy value. In this case, the left-hand value \u0060[]\u0060 is a truthy value, so \u0060\u0022Im\u0027\u0060 gets returned.\n\n\u0060\u0022\u0022\u0060 is a falsy value. If the left-hand value is falsy, nothing gets returned. \u0060n\u0027t\u0060 doesn\u0027t get returned."
  },
  {
    "id": "101",
    "question": "What\u0027s the value of output?\n\n\u0060\u0060\u0060javascript\nconst one = false || {} || null;\nconst two = null || false || \u0027\u0027;\nconst three = [] || 0 || true;\n\nconsole.log(one, two, three);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "false null []",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "null \u0022\u0022 true",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "{} \u0022\u0022 []",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "null null true",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060||\u0060 operator, we can return the first truthy operand. If all values are falsy, the last operand gets returned.\n\n\u0060(false || {} || null)\u0060: the empty object \u0060{}\u0060 is a truthy value. This is the first (and only) truthy value, which gets returned. \u0060one\u0060 is equal to \u0060{}\u0060.\n\n\u0060(null || false || \u0022\u0022)\u0060: all operands are falsy values. This means that the last operand, \u0060\u0022\u0022\u0060 gets returned. \u0060two\u0060 is equal to \u0060\u0022\u0022\u0060.\n\n\u0060([] || 0 || \u0022\u0022)\u0060: the empty array\u0060[]\u0060 is a truthy value. This is the first truthy value, which gets returned. \u0060three\u0060 is equal to \u0060[]\u0060."
  },
  {
    "id": "102",
    "question": "What\u0027s the value of output?\n\n\u0060\u0060\u0060javascript\nconst myPromise = () =\u003E Promise.resolve(\u0027I have resolved!\u0027);\n\nfunction firstFunction() {\n  myPromise().then(res =\u003E console.log(res));\n  console.log(\u0027second\u0027);\n}\n\nasync function secondFunction() {\n  console.log(await myPromise());\n  console.log(\u0027second\u0027);\n}\n\nfirstFunction();\nsecondFunction();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "I have resolved!, second and I have resolved!, second",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "second, I have resolved! and second, I have resolved!",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "I have resolved!, second and second, I have resolved!",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "second, I have resolved! and I have resolved!, second",
        "isCorrect": true
      }
    ],
    "explanation": "With a promise, we basically say _I want to execute this function, but I\u0027ll put it aside for now while it\u0027s running since this might take a while. Only when a certain value is resolved (or rejected), and when the call stack is empty, I want to use this value._\n\nWe can get this value with both \u0060.then\u0060 and the \u0060await\u0060 keyword in an \u0060async\u0060 function. Although we can get a promise\u0027s value with both \u0060.then\u0060 and \u0060await\u0060, they work a bit differently.\n\nIn the \u0060firstFunction\u0060, we (sort of) put the myPromise function aside while it was running, but continued running the other code, which is \u0060console.log(\u0027second\u0027)\u0060 in this case. Then, the function resolved with the string \u0060I have resolved\u0060, which then got logged after it saw that the callstack was empty.\n\nWith the await keyword in \u0060secondFunction\u0060, we literally pause the execution of an async function until the value has been resolved before moving to the next line.\n\nThis means that it waited for the \u0060myPromise\u0060 to resolve with the value \u0060I have resolved\u0060, and only once that happened, we moved to the next line: \u0060second\u0060 got logged."
  },
  {
    "id": "103",
    "question": "What\u0027s the value of output?\n\n\u0060\u0060\u0060javascript\nconst set = new Set();\n\nset.add(1);\nset.add(\u0027Lydia\u0027);\nset.add({ name: \u0027Lydia\u0027 });\n\nfor (let item of set) {\n  console.log(item \u002B 2);\n}\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "3, NaN, NaN",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "3, 7, NaN",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "3, Lydia2, [object Object]2",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "\u002212\u0022, Lydia2, [object Object]2",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060\u002B\u0060 operator is not only used for adding numerical values, but we can also use it to concatenate strings. Whenever the JavaScript engine sees that one or more values are not a number, it coerces the number into a string.\n\nThe first one is \u00601\u0060, which is a numerical value. \u00601 \u002B 2\u0060 returns the number 3.\n\nHowever, the second one is a string \u0060\u0022Lydia\u0022\u0060. \u0060\u0022Lydia\u0022\u0060 is a string and \u00602\u0060 is a number: \u00602\u0060 gets coerced into a string. \u0060\u0022Lydia\u0022\u0060 and \u0060\u00222\u0022\u0060 get concatenated, which results in the string \u0060\u0022Lydia2\u0022\u0060.\n\n\u0060{ name: \u0022Lydia\u0022 }\u0060 is an object. Neither a number nor an object is a string, so it stringifies both. Whenever we stringify a regular object, it becomes \u0060\u0022[object Object]\u0022\u0060. \u0060\u0022[object Object]\u0022\u0060 concatenated with \u0060\u00222\u0022\u0060 becomes \u0060\u0022[object Object]2\u0022\u0060."
  },
  {
    "id": "104",
    "question": "What\u0027s its value?\n\n\u0060\u0060\u0060javascript\nPromise.resolve(5);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "5",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Promise {\u003Cpending\u003E: 5}",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Promise\u00A0{\u003Cfulfilled\u003E: 5}",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "Error",
        "isCorrect": false
      }
    ],
    "explanation": "We can pass any type of value we want to \u0060Promise.resolve\u0060, either a promise or a non-promise. The method itself returns a promise with the resolved value (\u0060\u003Cfulfilled\u003E\u0060). If you pass a regular function, it\u0027ll be a resolved promise with a regular value. If you pass a promise, it\u0027ll be a resolved promise with the resolved value of that passed promise.\n\nIn this case, we just passed the numerical value \u00605\u0060. It returns a resolved promise with the value \u00605\u0060."
  },
  {
    "id": "105",
    "question": "What\u0027s its value?\n\n\u0060\u0060\u0060javascript\nfunction compareMembers(person1, person2 = person) {\n  if (person1 !== person2) {\n    console.log(\u0027Not the same!\u0027);\n  } else {\n    console.log(\u0027They are the same!\u0027);\n  }\n}\n\nconst person = { name: \u0027Lydia\u0027 };\n\ncompareMembers(person);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Not the same!",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "They are the same!",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "ReferenceError",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "SyntaxError",
        "isCorrect": false
      }
    ],
    "explanation": "Objects are passed by reference. When we check objects for strict equality (\u0060===\u0060), we\u0027re comparing their references.\n\nWe set the default value for \u0060person2\u0060 equal to the \u0060person\u0060 object, and passed the \u0060person\u0060 object as the value for \u0060person1\u0060.\n\nThis means that both values have a reference to the same spot in memory, thus they are equal.\n\nThe code block in the \u0060else\u0060 statement gets run, and \u0060They are the same!\u0060 gets logged."
  },
  {
    "id": "106",
    "question": "What\u0027s its value?\n\n\u0060\u0060\u0060javascript\nconst colorConfig = {\n  red: true,\n  blue: false,\n  green: true,\n  black: true,\n  yellow: false,\n};\n\nconst colors = [\u0027pink\u0027, \u0027red\u0027, \u0027blue\u0027];\n\nconsole.log(colorConfig.colors[1]);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "true",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "false",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "TypeError",
        "isCorrect": true
      }
    ],
    "explanation": "In JavaScript, we have two ways to access properties on an object: bracket notation, or dot notation. In this example, we use dot notation (\u0060colorConfig.colors\u0060) instead of bracket notation (\u0060colorConfig[\u0022colors\u0022]\u0060).\n\nWith dot notation, JavaScript tries to find the property on the object with that exact name. In this example, JavaScript tries to find a property called \u0060colors\u0060 on the \u0060colorConfig\u0060 object. There is no property called \u0060colors\u0060, so this returns \u0060undefined\u0060. Then, we try to access the value of the first element by using \u0060[1]\u0060. We cannot do this on a value that\u0027s \u0060undefined\u0060, so it throws a \u0060TypeError\u0060: \u0060Cannot read property \u00271\u0027 of undefined\u0060.\n\nJavaScript interprets (or unboxes) statements. When we use bracket notation, it sees the first opening bracket \u0060[\u0060 and keeps going until it finds the closing bracket \u0060]\u0060. Only then, it will evaluate the statement. If we would\u0027ve used \u0060colorConfig[colors[1]]\u0060, it would have returned the value of the \u0060red\u0060 property on the \u0060colorConfig\u0060 object."
  },
  {
    "id": "107",
    "question": "What\u0027s its value?\n\n\u0060\u0060\u0060javascript\nconsole.log(\u0027\u2764\uFE0F\u0027 === \u0027\u2764\uFE0F\u0027);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "true",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "false",
        "isCorrect": false
      }
    ],
    "explanation": "Under the hood, emojis are unicodes. The unicodes for the heart emoji is \u0060\u0022U\u002B2764 U\u002BFE0F\u0022\u0060. These are always the same for the same emojis, so we\u0027re comparing two equal strings to each other, which returns true."
  },
  {
    "id": "108",
    "question": "Which of these methods modifies the original array?\n\n\u0060\u0060\u0060javascript\nconst emojis = [\u0027\u2728\u0027, \u0027\uD83E\uDD51\u0027, \u0027\uD83D\uDE0D\u0027];\n\nemojis.map(x =\u003E x \u002B \u0027\u2728\u0027);\nemojis.filter(x =\u003E x !== \u0027\uD83E\uDD51\u0027);\nemojis.find(x =\u003E x !== \u0027\uD83E\uDD51\u0027);\nemojis.reduce((acc, cur) =\u003E acc \u002B \u0027\u2728\u0027);\nemojis.slice(1, 2, \u0027\u2728\u0027);\nemojis.splice(1, 2, \u0027\u2728\u0027);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "All of them",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "map reduce slice splice",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "map slice splice",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "splice",
        "isCorrect": true
      }
    ],
    "explanation": "With \u0060splice\u0060 method, we modify the original array by deleting, replacing or adding elements. In this case, we removed 2 items from index 1 (we removed \u0060\u0027\uD83E\uDD51\u0027\u0060 and \u0060\u0027\uD83D\uDE0D\u0027\u0060) and added the \u2728 emoji instead.\n\n\u0060map\u0060, \u0060filter\u0060 and \u0060slice\u0060 return a new array, \u0060find\u0060 returns an element, and \u0060reduce\u0060 returns a reduced value."
  },
  {
    "id": "109",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst food = [\u0027\uD83C\uDF55\u0027, \u0027\uD83C\uDF6B\u0027, \u0027\uD83E\uDD51\u0027, \u0027\uD83C\uDF54\u0027];\nconst info = { favoriteFood: food[0] };\n\ninfo.favoriteFood = \u0027\uD83C\uDF5D\u0027;\n\nconsole.log(food);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[\u0027\uD83C\uDF55\u0027, \u0027\uD83C\uDF6B\u0027, \u0027\uD83E\uDD51\u0027, \u0027\uD83C\uDF54\u0027]",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "[\u0027\uD83C\uDF5D\u0027, \u0027\uD83C\uDF6B\u0027, \u0027\uD83E\uDD51\u0027, \u0027\uD83C\uDF54\u0027]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[\u0027\uD83C\uDF5D\u0027, \u0027\uD83C\uDF55\u0027, \u0027\uD83C\uDF6B\u0027, \u0027\uD83E\uDD51\u0027, \u0027\uD83C\uDF54\u0027]",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "We set the value of the \u0060favoriteFood\u0060 property on the \u0060info\u0060 object equal to the string with the pizza emoji, \u0060\u0027\uD83C\uDF55\u0027\u0060. A string is a primitive data type. In JavaScript, primitive data types don\u0027t interact by reference.\n\nIn JavaScript, primitive data types (everything that\u0027s not an object) interact by _value_. In this case, we set the value of the \u0060favoriteFood\u0060 property on the \u0060info\u0060 object equal to the value of the first element in the \u0060food\u0060 array, the string with the pizza emoji in this case (\u0060\u0027\uD83C\uDF55\u0027\u0060). A string is a primitive data type, and interact by value (see my [blogpost](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference) if you\u0027re interested in learning more)\n\nThen, we change the value of the \u0060favoriteFood\u0060 property on the \u0060info\u0060 object. The \u0060food\u0060 array hasn\u0027t changed, since the value of \u0060favoriteFood\u0060 was merely a _copy_ of the value of the first element in the array, and doesn\u0027t have a reference to the same spot in memory as the element on \u0060food[0]\u0060. When we log food, it\u0027s still the original array, \u0060[\u0027\uD83C\uDF55\u0027, \u0027\uD83C\uDF6B\u0027, \u0027\uD83E\uDD51\u0027, \u0027\uD83C\uDF54\u0027]\u0060."
  },
  {
    "id": "110",
    "question": "What does this method do?\n\n\u0060\u0060\u0060javascript\nJSON.parse();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Parses JSON to a JavaScript value",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "Parses a JavaScript object to JSON",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Parses any JavaScript value to JSON",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Parses JSON to a JavaScript object only",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060JSON.parse()\u0060 method, we can parse JSON string to a JavaScript value.\n\n\u0060\u0060\u0060javascript\n// Stringifying a number into valid JSON, then parsing the JSON string to a JavaScript value:\nconst jsonNumber = JSON.stringify(4); // \u00274\u0027\nJSON.parse(jsonNumber); // 4\n\n// Stringifying an array value into valid JSON, then parsing the JSON string to a JavaScript value:\nconst jsonArray = JSON.stringify([1, 2, 3]); // \u0027[1, 2, 3]\u0027\nJSON.parse(jsonArray); // [1, 2, 3]\n\n// Stringifying an object  into valid JSON, then parsing the JSON string to a JavaScript value:\nconst jsonArray = JSON.stringify({ name: \u0027Lydia\u0027 }); // \u0027{\u0022name\u0022:\u0022Lydia\u0022}\u0027\nJSON.parse(jsonArray); // { name: \u0027Lydia\u0027 }\n\u0060\u0060\u0060"
  },
  {
    "id": "111",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nlet name = \u0027Lydia\u0027;\n\nfunction getName() {\n  console.log(name);\n  let name = \u0027Sarah\u0027;\n}\n\ngetName();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Lydia",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Sarah",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": true
      }
    ],
    "explanation": "Each function has its own _execution context_ (or _scope_). The \u0060getName\u0060 function first looks within its own context (scope) to see if it contains the variable \u0060name\u0060 we\u0027re trying to access. In this case, the \u0060getName\u0060 function contains its own \u0060name\u0060 variable: we declare the variable \u0060name\u0060 with the \u0060let\u0060 keyword, and with the value of \u0060\u0027Sarah\u0027\u0060.\n\nVariables with the \u0060let\u0060 keyword (and \u0060const\u0060) are hoisted, but unlike \u0060var\u0060, don\u0027t get \u003Ci\u003Einitialized\u003C/i\u003E. They are not accessible before the line we declare (initialize) them. This is called the \u0022temporal dead zone\u0022. When we try to access the variables before they are declared, JavaScript throws a \u0060ReferenceError\u0060.\n\nIf we wouldn\u0027t have declared the \u0060name\u0060 variable within the \u0060getName\u0060 function, the javascript engine would\u0027ve looked down the _scope chain_. The outer scope has a variable called \u0060name\u0060 with the value of \u0060Lydia\u0060. In that case, it would\u0027ve logged \u0060Lydia\u0060.\n\n\u0060\u0060\u0060javascript\nlet name = \u0027Lydia\u0027;\n\nfunction getName() {\n  console.log(name);\n}\n\ngetName(); // Lydia\n\u0060\u0060\u0060"
  },
  {
    "id": "112",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction* generatorOne() {\n  yield [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027];\n}\n\nfunction* generatorTwo() {\n  yield* [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027];\n}\n\nconst one = generatorOne();\nconst two = generatorTwo();\n\nconsole.log(one.next().value);\nconsole.log(two.next().value);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "a and a",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "a and undefined",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027] and a",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "a and [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060yield\u0060 keyword, we \u0060yield\u0060 values in a generator function. With the \u0060yield*\u0060 keyword, we can yield values from another generator function, or iterable object (for example an array).\n\nIn \u0060generatorOne\u0060, we yield the entire array \u0060[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]\u0060 using the \u0060yield\u0060 keyword. The value of \u0060value\u0060 property on the object returned by the \u0060next\u0060 method on \u0060one\u0060 (\u0060one.next().value\u0060) is equal to the entire array \u0060[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]\u0060.\n\n\u0060\u0060\u0060javascript\nconsole.log(one.next().value); // [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]\nconsole.log(one.next().value); // undefined\n\u0060\u0060\u0060\n\nIn \u0060generatorTwo\u0060, we use the \u0060yield*\u0060 keyword. This means that the first yielded value of \u0060two\u0060, is equal to the first yielded value in the iterator. The iterator is the array \u0060[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]\u0060. The first yielded value is \u0060a\u0060, so the first time we call \u0060two.next().value\u0060, \u0060a\u0060 is returned.\n\n\u0060\u0060\u0060javascript\nconsole.log(two.next().value); // \u0027a\u0027\nconsole.log(two.next().value); // \u0027b\u0027\nconsole.log(two.next().value); // \u0027c\u0027\nconsole.log(two.next().value); // undefined\n\u0060\u0060\u0060"
  },
  {
    "id": "113",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconsole.log(\u0060${(x =\u003E x)(\u0027I love\u0027)} to program\u0060);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "I love to program",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "undefined to program",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "${(x =\u003E x)(\u0027I love\u0027) to program",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "TypeError",
        "isCorrect": false
      }
    ],
    "explanation": "Expressions within template literals are evaluated first. This means that the string will contain the returned value of the expression, the immediately invoked function \u0060(x =\u003E x)(\u0027I love\u0027)\u0060 in this case. We pass the value \u0060\u0027I love\u0027\u0060 as an argument to the \u0060x =\u003E x\u0060 arrow function. \u0060x\u0060 is equal to \u0060\u0027I love\u0027\u0060, which gets returned. This results in \u0060I love to program\u0060."
  },
  {
    "id": "114",
    "question": "What will happen?\n\n\u0060\u0060\u0060javascript\nlet config = {\n  alert: setInterval(() =\u003E {\n    console.log(\u0027Alert!\u0027);\n  }, 1000),\n};\n\nconfig = null;\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "The setInterval callback won\u0027t be invoked",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "The setInterval callback gets invoked once",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "The setInterval callback will still be called every second",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "We never invoked config.alert(), config is null",
        "isCorrect": false
      }
    ],
    "explanation": "Normally when we set objects equal to \u0060null\u0060, those objects get _garbage collected_ as there is no reference anymore to that object. However, since the callback function within \u0060setInterval\u0060 is an arrow function (thus bound to the \u0060config\u0060 object), the callback function still holds a reference to the \u0060config\u0060 object. \nAs long as there is a reference, the object won\u0027t get garbage collected. \nSince this is an interval, setting \u0060config\u0060 to \u0060null\u0060 or \u0060delete\u0060-ing \u0060config.alert\u0060 won\u0027t garbage-collect the interval, so the interval will still be called. \nIt should be cleared with \u0060clearInterval(config.alert)\u0060 to remove it from memory.\nSince it was not cleared, the \u0060setInterval\u0060 callback function will still get invoked every 1000ms (1s)."
  },
  {
    "id": "115",
    "question": "Which method(s) will return the value \u0060\u0027Hello world!\u0027\u0060?\n\n\u0060\u0060\u0060javascript\nconst myMap = new Map();\nconst myFunc = () =\u003E \u0027greeting\u0027;\n\nmyMap.set(myFunc, \u0027Hello world!\u0027);\n\n//1\nmyMap.get(\u0027greeting\u0027);\n//2\nmyMap.get(myFunc);\n//3\nmyMap.get(() =\u003E \u0027greeting\u0027);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "1",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "2",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "2 and 3",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "All of them",
        "isCorrect": false
      }
    ],
    "explanation": "When adding a key/value pair using the \u0060set\u0060 method, the key will be the value of the first argument passed to the \u0060set\u0060 function, and the value will be the second argument passed to the \u0060set\u0060 function. The key is the _function_ \u0060() =\u003E \u0027greeting\u0027\u0060 in this case, and the value \u0060\u0027Hello world\u0027\u0060. \u0060myMap\u0060 is now \u0060{ () =\u003E \u0027greeting\u0027 =\u003E \u0027Hello world!\u0027 }\u0060.\n\n1 is wrong, since the key is not \u0060\u0027greeting\u0027\u0060 but \u0060() =\u003E \u0027greeting\u0027\u0060.\n3 is wrong, since we\u0027re creating a new function by passing it as a parameter to the \u0060get\u0060 method. Object interact by _reference_. Functions are objects, which is why two functions are never strictly equal, even if they are identical: they have a reference to a different spot in memory."
  },
  {
    "id": "116",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst person = {\n  name: \u0027Lydia\u0027,\n  age: 21,\n};\n\nconst changeAge = (x = { ...person }) =\u003E (x.age \u002B= 1);\nconst changeAgeAndName = (x = { ...person }) =\u003E {\n  x.age \u002B= 1;\n  x.name = \u0027Sarah\u0027;\n};\n\nchangeAge(person);\nchangeAgeAndName();\n\nconsole.log(person);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{name: \u0022Sarah\u0022, age: 22}",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "{name: \u0022Sarah\u0022, age: 23}",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "{name: \u0022Lydia\u0022, age: 22}",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "{name: \u0022Lydia\u0022, age: 23}",
        "isCorrect": false
      }
    ],
    "explanation": "Both the \u0060changeAge\u0060 and \u0060changeAgeAndName\u0060 functions have a default parameter, namely a _newly_ created object \u0060{ ...person }\u0060. This object has copies of all the key/values in the \u0060person\u0060 object.\n\nFirst, we invoke the \u0060changeAge\u0060 function and pass the \u0060person\u0060 object as its argument. This function increases the value of the \u0060age\u0060 property by 1. \u0060person\u0060 is now \u0060{ name: \u0022Lydia\u0022, age: 22 }\u0060.\n\nThen, we invoke the \u0060changeAgeAndName\u0060 function, however we don\u0027t pass a parameter. Instead, the value of \u0060x\u0060 is equal to a _new_ object: \u0060{ ...person }\u0060. Since it\u0027s a new object, it doesn\u0027t affect the values of the properties on the \u0060person\u0060 object. \u0060person\u0060 is still equal to \u0060{ name: \u0022Lydia\u0022, age: 22 }\u0060."
  },
  {
    "id": "117",
    "question": "Which of the following options will return \u00606\u0060?\n\n\u0060\u0060\u0060javascript\nfunction sumValues(x, y, z) {\n  return x \u002B y \u002B z;\n}\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "sumValues([...1, 2, 3])",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "sumValues([...[1, 2, 3]])",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "sumValues(...[1, 2, 3])",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "sumValues([1, 2, 3])",
        "isCorrect": false
      }
    ],
    "explanation": "With the spread operator \u0060...\u0060, we can _spread_ iterables to individual elements. The \u0060sumValues\u0060 function receives three arguments: \u0060x\u0060, \u0060y\u0060 and \u0060z\u0060. \u0060...[1, 2, 3]\u0060 will result in \u00601, 2, 3\u0060, which we pass to the \u0060sumValues\u0060 function."
  },
  {
    "id": "118",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nlet num = 1;\nconst list = [\u0027\uD83E\uDD73\u0027, \u0027\uD83E\uDD20\u0027, \u0027\uD83E\uDD70\u0027, \u0027\uD83E\uDD2A\u0027];\n\nconsole.log(list[(num \u002B= 1)]);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\uD83E\uDD20",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\uD83E\uDD70",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "SyntaxError",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060\u002B=\u0060 operand, we\u0027re incrementing the value of \u0060num\u0060 by \u00601\u0060. \u0060num\u0060 had the initial value \u00601\u0060, so \u00601 \u002B 1\u0060 is \u00602\u0060. The item on the second index in the \u0060list\u0060 array is \uD83E\uDD70, \u0060console.log(list[2])\u0060 prints \uD83E\uDD70."
  },
  {
    "id": "119",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst person = {\n  firstName: \u0027Lydia\u0027,\n  lastName: \u0027Hallie\u0027,\n  pet: {\n    name: \u0027Mara\u0027,\n    breed: \u0027Dutch Tulip Hound\u0027,\n  },\n  getFullName() {\n    return \u0060${this.firstName} ${this.lastName}\u0060;\n  },\n};\n\nconsole.log(person.pet?.name);\nconsole.log(person.pet?.family?.name);\nconsole.log(person.getFullName?.());\nconsole.log(member.getLastName?.());\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "undefined undefined undefined undefined",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Mara undefined Lydia Hallie ReferenceError",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "Mara null Lydia Hallie null",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "null ReferenceError null ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "With the optional chaining operator \u0060?.\u0060, we no longer have to explicitly check whether the deeper nested values are valid or not. If we\u0027re trying to access a property on an \u0060undefined\u0060 or \u0060null\u0060 value (_nullish_), the expression short-circuits and returns \u0060undefined\u0060.\n\n\u0060person.pet?.name\u0060: \u0060person\u0060 has a property named \u0060pet\u0060: \u0060person.pet\u0060 is not nullish. It has a property called \u0060name\u0060, and returns \u0060Mara\u0060.\n\u0060person.pet?.family?.name\u0060: \u0060person\u0060 has a property named \u0060pet\u0060: \u0060person.pet\u0060 is not nullish. \u0060pet\u0060 does _not_ have a property called \u0060family\u0060, \u0060person.pet.family\u0060 is nullish. The expression returns \u0060undefined\u0060.\n\u0060person.getFullName?.()\u0060: \u0060person\u0060 has a property named \u0060getFullName\u0060: \u0060person.getFullName()\u0060 is not nullish and can get invoked, which returns \u0060Lydia Hallie\u0060.\n\u0060member.getLastName?.()\u0060: variable \u0060member\u0060 is non existent therefore a \u0060ReferenceError\u0060 gets thrown!"
  },
  {
    "id": "120",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst groceries = [\u0027banana\u0027, \u0027apple\u0027, \u0027peanuts\u0027];\n\nif (groceries.indexOf(\u0027banana\u0027)) {\n  console.log(\u0027We have to buy bananas!\u0027);\n} else {\n  console.log(\u0060We don\u0027t have to buy bananas!\u0060);\n}\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "We have to buy bananas!",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "We don\u0027t have to buy bananas",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "1",
        "isCorrect": false
      }
    ],
    "explanation": "We passed the condition \u0060groceries.indexOf(\u0022banana\u0022)\u0060 to the if-statement. \u0060groceries.indexOf(\u0022banana\u0022)\u0060 returns \u00600\u0060, which is a falsy value. Since the condition in the if-statement is falsy, the code in the \u0060else\u0060 block runs, and \u0060We don\u0027t have to buy bananas!\u0060 gets logged."
  },
  {
    "id": "121",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst config = {\n  languages: [],\n  set language(lang) {\n    return this.languages.push(lang);\n  },\n};\n\nconsole.log(config.language);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "function language(lang) { this.languages.push(lang }",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "0",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[]",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined",
        "isCorrect": true
      }
    ],
    "explanation": "The \u0060language\u0060 method is a \u0060setter\u0060. Setters don\u0027t hold an actual value, their purpose is to _modify_ properties. When calling a \u0060setter\u0060 method, \u0060undefined\u0060 gets returned."
  },
  {
    "id": "122",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst name = \u0027Lydia Hallie\u0027;\n\nconsole.log(!typeof name === \u0027object\u0027);\nconsole.log(!typeof name === \u0027string\u0027);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "false true",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "true false",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "false false",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "true true",
        "isCorrect": false
      }
    ],
    "explanation": "\u0060typeof name\u0060 returns \u0060\u0022string\u0022\u0060. The string \u0060\u0022string\u0022\u0060 is a truthy value, so \u0060!typeof name\u0060 returns the boolean value \u0060false\u0060. \u0060false === \u0022object\u0022\u0060 and \u0060false === \u0022string\u0022\u0060 both return\u0060false\u0060.\n\n(If we wanted to check whether the type was (un)equal to a certain type, we should\u0027ve written \u0060!==\u0060 instead of \u0060!typeof\u0060)"
  },
  {
    "id": "123",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst add = x =\u003E y =\u003E z =\u003E {\n  console.log(x, y, z);\n  return x \u002B y \u002B z;\n};\n\nadd(4)(5)(6);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "4 5 6",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "6 5 4",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "4 function function",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined undefined 6",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060add\u0060 function returns an arrow function, which returns an arrow function, which returns an arrow function (still with me?). The first function receives an argument \u0060x\u0060 with the value of \u00604\u0060. We invoke the second function, which receives an argument \u0060y\u0060 with the value \u00605\u0060. Then we invoke the third function, which receives an argument \u0060z\u0060 with the value \u00606\u0060. When we\u0027re trying to access the value \u0060x\u0060, \u0060y\u0060 and \u0060z\u0060 within the last arrow function, the JS engine goes up the scope chain in order to find the values for \u0060x\u0060 and \u0060y\u0060 accordingly. This returns \u00604\u0060 \u00605\u0060 \u00606\u0060."
  },
  {
    "id": "124",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nasync function* range(start, end) {\n  for (let i = start; i \u003C= end; i\u002B\u002B) {\n    yield Promise.resolve(i);\n  }\n}\n\n(async () =\u003E {\n  const gen = range(1, 3);\n  for await (const item of gen) {\n    console.log(item);\n  }\n})();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Promise {1} Promise {2} Promise {3}",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Promise {\u003Cpending\u003E} Promise {\u003Cpending\u003E} Promise {\u003Cpending\u003E}",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "1 2 3",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "undefined undefined undefined",
        "isCorrect": false
      }
    ],
    "explanation": "The generator function \u0060range\u0060 returns an async object with promises for each item in the range we pass: \u0060Promise{1}\u0060, \u0060Promise{2}\u0060, \u0060Promise{3}\u0060. We set the variable \u0060gen\u0060 equal to the async object, after which we loop over it using a \u0060for await ... of\u0060 loop. We set the variable \u0060item\u0060 equal to the returned Promise values: first \u0060Promise{1}\u0060, then \u0060Promise{2}\u0060, then \u0060Promise{3}\u0060. Since we\u0027re _awaiting_ the value of \u0060item\u0060, the resolved promise, the resolved _values_ of the promises get returned: \u00601\u0060, \u00602\u0060, then \u00603\u0060."
  },
  {
    "id": "125",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst myFunc = ({ x, y, z }) =\u003E {\n  console.log(x, y, z);\n};\n\nmyFunc(1, 2, 3);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "1 2 3",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "{1: 1} {2: 2} {3: 3}",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "{ 1: undefined } undefined undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined undefined undefined",
        "isCorrect": true
      }
    ],
    "explanation": "\u0060myFunc\u0060 expects an object with properties \u0060x\u0060, \u0060y\u0060 and \u0060z\u0060 as its argument. Since we\u0027re only passing three separate numeric values (1, 2, 3) instead of one object with properties \u0060x\u0060, \u0060y\u0060 and \u0060z\u0060 ({x: 1, y: 2, z: 3}), \u0060x\u0060, \u0060y\u0060 and \u0060z\u0060 have their default value of \u0060undefined\u0060."
  },
  {
    "id": "126",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction getFine(speed, amount) {\n  const formattedSpeed = new Intl.NumberFormat(\u0027en",
    "answers": [
      {
        "index": "US\u0027, {\n    style",
        "answer": "\u0027unit\u0027,",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060Intl.NumberFormat\u0060 method, we can format numeric values to any locale. We format the numeric value \u0060130\u0060 to the \u0060en-US\u0060 locale as a \u0060unit\u0060 in \u0060mile-per-hour\u0060, which results in \u0060130 mph\u0060. The numeric value \u0060300\u0060 to the \u0060en-US\u0060 locale as a \u0060currency\u0060 in \u0060USD\u0060 results in \u0060$300.00\u0060."
  },
  {
    "id": "127",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst spookyItems = [\u0027\uD83D\uDC7B\u0027, \u0027\uD83C\uDF83\u0027, \u0027\uD83D\uDD78\u0027];\n({ item: spookyItems[3] } = { item: \u0027\uD83D\uDC80\u0027 });\n\nconsole.log(spookyItems);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[\u0022\uD83D\uDC7B\u0022, \u0022\uD83C\uDF83\u0022, \u0022\uD83D\uDD78\u0022]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[\u0022\uD83D\uDC7B\u0022, \u0022\uD83C\uDF83\u0022, \u0022\uD83D\uDD78\u0022, \u0022\uD83D\uDC80\u0022]",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "[\u0022\uD83D\uDC7B\u0022, \u0022\uD83C\uDF83\u0022, \u0022\uD83D\uDD78\u0022, { item: \u0022\uD83D\uDC80\u0022 }]",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "[\u0022\uD83D\uDC7B\u0022, \u0022\uD83C\uDF83\u0022, \u0022\uD83D\uDD78\u0022, \u0022[object Object]\u0022]",
        "isCorrect": false
      }
    ],
    "explanation": "By destructuring objects, we can unpack values from the right-hand object, and assign the unpacked value to the value of the same property name on the left-hand object. In this case, we\u0027re assigning the value \u0022\uD83D\uDC80\u0022 to \u0060spookyItems[3]\u0060. This means that we\u0027re modifying the \u0060spookyItems\u0060 array, we\u0027re adding the \u0022\uD83D\uDC80\u0022 to it. When logging \u0060spookyItems\u0060, \u0060[\u0022\uD83D\uDC7B\u0022, \u0022\uD83C\uDF83\u0022, \u0022\uD83D\uDD78\u0022, \u0022\uD83D\uDC80\u0022]\u0060 gets logged."
  },
  {
    "id": "128",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst name = \u0027Lydia Hallie\u0027;\nconst age = 21;\n\nconsole.log(Number.isNaN(name));\nconsole.log(Number.isNaN(age));\n\nconsole.log(isNaN(name));\nconsole.log(isNaN(age));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "true false true false",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "true false false false",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "false false true false",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "false true false true",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060Number.isNaN\u0060 method, you can check if the value you pass is a _numeric value_ and equal to \u0060NaN\u0060. \u0060name\u0060 is not a numeric value, so \u0060Number.isNaN(name)\u0060 returns \u0060false\u0060. \u0060age\u0060 is a numeric value, but is not equal to \u0060NaN\u0060, so \u0060Number.isNaN(age)\u0060 returns \u0060false\u0060.\n\nWith the \u0060isNaN\u0060 method, you can check if the value you pass is not a number. \u0060name\u0060 is not a number, so \u0060isNaN(name)\u0060 returns true. \u0060age\u0060 is a number, so \u0060isNaN(age)\u0060 returns \u0060false\u0060."
  },
  {
    "id": "129",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst randomValue = 21;\n\nfunction getInfo() {\n  console.log(typeof randomValue);\n  const randomValue = \u0027Lydia Hallie\u0027;\n}\n\ngetInfo();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "\u0022number\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "\u0022string\u0022",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": true
      }
    ],
    "explanation": "Variables declared with the \u0060const\u0060 keyword are not referenceable before their initialization: this is called the _temporal dead zone_. In the \u0060getInfo\u0060 function, the variable \u0060randomValue\u0060 is scoped in the functional scope of \u0060getInfo\u0060. On the line where we want to log the value of \u0060typeof randomValue\u0060, the variable \u0060randomValue\u0060 isn\u0027t initialized yet: a \u0060ReferenceError\u0060 gets thrown! The engine didn\u0027t go down the scope chain since we declared the variable \u0060randomValue\u0060 in the \u0060getInfo\u0060 function."
  },
  {
    "id": "130",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst myPromise = Promise.resolve(\u0027Woah some cool data\u0027);\n\n(async () =\u003E {\n  try {\n    console.log(await myPromise);\n  } catch {\n    throw new Error(\u0060Oops didn\u0027t work\u0060);\n  } finally {\n    console.log(\u0027Oh finally!\u0027);\n  }\n})();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Woah some cool data",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Oh finally!",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Woah some cool data Oh finally!",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "Oops didn\u0027t work Oh finally!",
        "isCorrect": false
      }
    ],
    "explanation": "In the \u0060try\u0060 block, we\u0027re logging the awaited value of the \u0060myPromise\u0060 variable: \u0060\u0022Woah some cool data\u0022\u0060. Since no errors were thrown in the \u0060try\u0060 block, the code in the \u0060catch\u0060 block doesn\u0027t run. The code in the \u0060finally\u0060 block _always_ runs, \u0060\u0022Oh finally!\u0022\u0060 gets logged."
  },
  {
    "id": "131",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst emojis = [\u0027\uD83E\uDD51\u0027, [\u0027\u2728\u0027, \u0027\u2728\u0027, [\u0027\uD83C\uDF55\u0027, \u0027\uD83C\uDF55\u0027]]];\n\nconsole.log(emojis.flat(1));\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[\u0027\uD83E\uDD51\u0027, [\u0027\u2728\u0027, \u0027\u2728\u0027, [\u0027\uD83C\uDF55\u0027, \u0027\uD83C\uDF55\u0027]]]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[\u0027\uD83E\uDD51\u0027, \u0027\u2728\u0027, \u0027\u2728\u0027, [\u0027\uD83C\uDF55\u0027, \u0027\uD83C\uDF55\u0027]]",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "[\u0027\uD83E\uDD51\u0027, [\u0027\u2728\u0027, \u0027\u2728\u0027, \u0027\uD83C\uDF55\u0027, \u0027\uD83C\uDF55\u0027]]",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "[\u0027\uD83E\uDD51\u0027, \u0027\u2728\u0027, \u0027\u2728\u0027, \u0027\uD83C\uDF55\u0027, \u0027\uD83C\uDF55\u0027]",
        "isCorrect": false
      }
    ],
    "explanation": "With the \u0060flat\u0060 method, we can create a new, flattened array. The depth of the flattened array depends on the value that we pass. In this case, we passed the value \u00601\u0060 (which we didn\u0027t have to, that\u0027s the default value), meaning that only the arrays on the first depth will be concatenated. \u0060[\u0027\uD83E\uDD51\u0027]\u0060 and \u0060[\u0027\u2728\u0027, \u0027\u2728\u0027, [\u0027\uD83C\uDF55\u0027, \u0027\uD83C\uDF55\u0027]]\u0060 in this case. Concatenating these two arrays results in \u0060[\u0027\uD83E\uDD51\u0027, \u0027\u2728\u0027, \u0027\u2728\u0027, [\u0027\uD83C\uDF55\u0027, \u0027\uD83C\uDF55\u0027]]\u0060."
  },
  {
    "id": "132",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nclass Counter {\n  constructor() {\n    this.count = 0;\n  }\n\n  increment() {\n    this.count\u002B\u002B;\n  }\n}\n\nconst counterOne = new Counter();\ncounterOne.increment();\ncounterOne.increment();\n\nconst counterTwo = counterOne;\ncounterTwo.increment();\n\nconsole.log(counterOne.count);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "0",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "1",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "2",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "3",
        "isCorrect": true
      }
    ],
    "explanation": "\u0060counterOne\u0060 is an instance of the \u0060Counter\u0060 class. The counter class contains a \u0060count\u0060 property on its constructor, and an \u0060increment\u0060 method. First, we invoked the \u0060increment\u0060 method twice by calling \u0060counterOne.increment()\u0060. Currently, \u0060counterOne.count\u0060 is \u00602\u0060.\n\n\u003Cimg src=\u0022https://i.imgur.com/KxLlTm9.png\u0022 width=\u0022400\u0022\u003E\n\nThen, we create a new variable \u0060counterTwo\u0060, and set it equal to \u0060counterOne\u0060. Since objects interact by reference, we\u0027re just creating a new reference to the same spot in memory that \u0060counterOne\u0060 points to. Since it has the same spot in memory, any changes made to the object that \u0060counterTwo\u0060 has a reference to, also apply to \u0060counterOne\u0060. Currently, \u0060counterTwo.count\u0060 is \u00602\u0060.\n\nWe invoke \u0060counterTwo.increment()\u0060, which sets \u0060count\u0060 to \u00603\u0060. Then, we log the count on \u0060counterOne\u0060, which logs \u00603\u0060.\n\n\u003Cimg src=\u0022https://i.imgur.com/BNBHXmc.png\u0022 width=\u0022400\u0022\u003E"
  },
  {
    "id": "133",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst myPromise = Promise.resolve(Promise.resolve(\u0027Promise\u0027));\n\nfunction funcOne() {\n  setTimeout(() =\u003E console.log(\u0027Timeout 1!\u0027), 0);\n  myPromise.then(res =\u003E res).then(res =\u003E console.log(\u0060${res} 1!\u0060));\n  console.log(\u0027Last line 1!\u0027);\n}\n\nasync function funcTwo() {\n  const res = await myPromise;\n  console.log(\u0060${res} 2!\u0060)\n  setTimeout(() =\u003E console.log(\u0027Timeout 2!\u0027), 0);\n  console.log(\u0027Last line 2!\u0027);\n}\n\nfuncOne();\nfuncTwo();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Promise 1! Last line 1! Promise 2! Last line 2! Timeout 1! Timeout 2!",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Last line 1! Timeout 1! Promise 1! Last line 2! Promise2! Timeout 2! ",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Last line 1! Promise 2! Last line 2! Promise 1! Timeout 1! Timeout 2!",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "Timeout 1! Promise 1! Last line 1! Promise 2! Timeout 2! Last line 2!",
        "isCorrect": false
      }
    ],
    "explanation": "First, we invoke \u0060funcOne\u0060. On the first line of \u0060funcOne\u0060, we call the _asynchronous_ \u0060setTimeout\u0060 function, from which the callback is sent to the Web API. (see my article on the event loop \u003Ca href=\u0022https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif\u0022\u003Ehere\u003C/a\u003E.)\n\nThen we call the \u0060myPromise\u0060 promise, which is an _asynchronous_ operation.\n\nBoth the promise and the timeout are asynchronous operations, the function keeps on running while it\u0027s busy completing the promise and handling the \u0060setTimeout\u0060 callback. This means that \u0060Last line 1!\u0060 gets logged first, since this is not an asynchonous operation. \n\nSince the callstack is not empty yet, the \u0060setTimeout\u0060 function and promise in \u0060funcOne\u0060 cannot get added to the callstack yet.\n\nIn \u0060funcTwo\u0060, the variable \u0060res\u0060 gets \u0060Promise\u0060 because \u0060Promise.resolve(Promise.resolve(\u0027Promise\u0027))\u0060 is equivalent to \u0060Promise.resolve(\u0027Promise\u0027)\u0060 since resolving a promise just resolves it\u0027s value. The \u0060await\u0060 in this line stops the execution of the function until it receives the resolution of the promise and then keeps on running synchronously until completion, so \u0060Promise 2!\u0060 and then \u0060Last line 2!\u0060 are logged and the \u0060setTimeout\u0060 is sent to the Web API.\n\nThen the call stack is empty. Promises are _microtasks_ so they are resolved first when the call stack is empty so \u0060Promise 1!\u0060 gets to be logged.\n\nNow, since \u0060funcTwo\u0060 popped off the call stack, the call stack is empty. The callbacks waiting in the queue (\u0060() =\u003E console.log(\u0022Timeout 1!\u0022)\u0060 from \u0060funcOne\u0060, and \u0060() =\u003E console.log(\u0022Timeout 2!\u0022)\u0060 from \u0060funcTwo\u0060) get added to the call stack one by one. The first callback logs \u0060Timeout 1!\u0060, and gets popped off the stack. Then, the second callback logs \u0060Timeout 2!\u0060, and gets popped off the stack."
  },
  {
    "id": "134",
    "question": "How can we invoke \u0060sum\u0060 in \u0060sum.js\u0060 from \u0060index.js?\u0060\n\n\u0060\u0060\u0060javascript\n// sum.js\nexport default function sum(x) {\n  return x \u002B x;\n}\n\n// index.js\nimport * as sum from \u0027./sum\u0027;\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "sum(4)",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "sum.sum(4)",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "sum.default(4)",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "Default aren\u0027t imported with *, only named exports",
        "isCorrect": false
      }
    ],
    "explanation": "With the asterisk \u0060*\u0060, we import all exported values from that file, both default and named. If we had the following file:\n\n\u0060\u0060\u0060javascript\n// info.js\nexport const name = \u0027Lydia\u0027;\nexport const age = 21;\nexport default \u0027I love JavaScript\u0027;\n\n// index.js\nimport * as info from \u0027./info\u0027;\nconsole.log(info);\n\u0060\u0060\u0060\n\nThe following would get logged:\n\n\u0060\u0060\u0060javascript\n{\n  default: \u0022I love JavaScript\u0022,\n  name: \u0022Lydia\u0022,\n  age: 21\n}\n\u0060\u0060\u0060\n\nFor the \u0060sum\u0060 example, it means that the imported value \u0060sum\u0060 looks like this:\n\n\u0060\u0060\u0060javascript\n{ default: function sum(x) { return x \u002B x } }\n\u0060\u0060\u0060\n\nWe can invoke this function, by calling \u0060sum.default\u0060"
  },
  {
    "id": "135",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst handler = {\n  set: () =\u003E console.log(\u0027Added a new property!\u0027),\n  get: () =\u003E console.log(\u0027Accessed a property!\u0027),\n};\n\nconst person = new Proxy({}, handler);\n\nperson.name = \u0027Lydia\u0027;\nperson.name;\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Added a new property!",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Accessed a property!",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "Added a new property! Accessed a property!",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "Nothing gets logged",
        "isCorrect": false
      }
    ],
    "explanation": "With a Proxy object, we can add custom behavior to an object that we pass to it as the second argument. In this case, we pass the \u0060handler\u0060 object which contained two properties: \u0060set\u0060 and \u0060get\u0060. \u0060set\u0060 gets invoked whenever we _set_ property values, \u0060get\u0060 gets invoked whenever we _get_ (access) property values.\n\nThe first argument is an empty object \u0060{}\u0060, which is the value of \u0060person\u0060. To this object, the custom behavior specified in the \u0060handler\u0060 object gets added. If we add a property to the \u0060person\u0060 object, \u0060set\u0060 will get invoked. If we access a property on the \u0060person\u0060 object, \u0060get\u0060 gets invoked.\n\nFirst, we added a new property \u0060name\u0060 to the proxy object (\u0060person.name = \u0022Lydia\u0022\u0060). \u0060set\u0060 gets invoked, and logs \u0060\u0022Added a new property!\u0022\u0060.\n\nThen, we access a property value on the proxy object, the \u0060get\u0060 property on the handler object got invoked. \u0060\u0022Accessed a property!\u0022\u0060 gets logged."
  },
  {
    "id": "136",
    "question": "Which of the following will modify the \u0060person\u0060 object?\n\n\u0060\u0060\u0060javascript\nconst person = { name: \u0027Lydia Hallie\u0027 };\n\nObject.seal(person);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "person.name = \u0022Evan Bacon\u0022",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "person.age = 21",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "delete person.name",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Object.assign(person, { age: 21 })",
        "isCorrect": false
      }
    ],
    "explanation": "With \u0060Object.seal\u0060 we can prevent new properties from being _added_, or existing properties to be _removed_.\n\nHowever, you can still modify the value of existing properties."
  },
  {
    "id": "137",
    "question": "Which of the following will modify the \u0060person\u0060 object?\n\n\u0060\u0060\u0060javascript\nconst person = {\n  name: \u0027Lydia Hallie\u0027,\n  address: {\n    street: \u0027100 Main St\u0027,\n  },\n};\n\nObject.freeze(person);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "person.name = \u0022Evan Bacon\u0022",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "delete person.address",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "person.address.street = \u0022101 Main St\u0022",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "person.pet = { name: \u0022Mara\u0022 }",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060Object.freeze\u0060 method _freezes_ an object. No properties can be added, modified, or removed.\n\nHowever, it only _shallowly_ freezes the object, meaning that only _direct_ properties on the object are frozen. If the property is another object, like \u0060address\u0060 in this case, the properties on that object aren\u0027t frozen, and can be modified."
  },
  {
    "id": "138",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst add = x =\u003E x \u002B x;\n\nfunction myFunc(num = 2, value = add(num)) {\n  console.log(num, value);\n}\n\nmyFunc();\nmyFunc(3);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "2 4 and 3 6",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "2 NaN and 3 NaN",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "2 Error and 3 6",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "2 4 and 3 Error",
        "isCorrect": false
      }
    ],
    "explanation": "First, we invoked \u0060myFunc()\u0060 without passing any arguments. Since we didn\u0027t pass arguments, \u0060num\u0060 and \u0060value\u0060 got their default values: num is \u00602\u0060, and \u0060value\u0060 the returned value of the function \u0060add\u0060. To the \u0060add\u0060 function, we pass \u0060num\u0060 as an argument, which had the value of \u00602\u0060. \u0060add\u0060 returns \u00604\u0060, which is the value of \u0060value\u0060.\n\nThen, we invoked \u0060myFunc(3)\u0060 and passed the value \u00603\u0060 as the value for the argument \u0060num\u0060. We didn\u0027t pass an argument for \u0060value\u0060. Since we didn\u0027t pass a value for the \u0060value\u0060 argument, it got the default value: the returned value of the \u0060add\u0060 function. To \u0060add\u0060, we pass \u0060num\u0060, which has the value of \u00603\u0060. \u0060add\u0060 returns \u00606\u0060, which is the value of \u0060value\u0060."
  },
  {
    "id": "139",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nclass Counter {\n  #number = 10\n\n  increment() {\n    this.#number\u002B\u002B\n  }\n\n  getNum() {\n    return this.#number\n  }\n}\n\nconst counter = new Counter()\ncounter.increment()\n\nconsole.log(counter.#number)\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "10",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "11",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "SyntaxError",
        "isCorrect": true
      }
    ],
    "explanation": "In ES2020, we can add private variables in classes by using the \u0060#\u0060. We cannot access these variables outside of the class. When we try to log \u0060counter.#number\u0060, a SyntaxError gets thrown: we cannot acccess it outside the \u0060Counter\u0060 class!"
  },
  {
    "id": "140",
    "question": "What\u0027s missing?\n\n\u0060\u0060\u0060javascript\nconst teams = [\n  { name: \u0027Team 1\u0027, members: [\u0027Paul\u0027, \u0027Lisa\u0027] },\n  { name: \u0027Team 2\u0027, members: [\u0027Laura\u0027, \u0027Tim\u0027] },\n];\n\nfunction* getMembers(members) {\n  for (let i = 0; i \u003C members.length; i\u002B\u002B) {\n    yield members[i];\n  }\n}\n\nfunction* getTeams(teams) {\n  for (let i = 0; i \u003C teams.length; i\u002B\u002B) {\n    // \u2728 SOMETHING IS MISSING HERE \u2728\n  }\n}\n\nconst obj = getTeams(teams);\nobj.next(); // { value: \u0022Paul\u0022, done: false }\nobj.next(); // { value: \u0022Lisa\u0022, done: false }\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "yield getMembers(teams[i].members)",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "yield* getMembers(teams[i].members)",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "return getMembers(teams[i].members)",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "return yield getMembers(teams[i].members)",
        "isCorrect": false
      }
    ],
    "explanation": "In order to iterate over the \u0060members\u0060 in each element in the \u0060teams\u0060 array, we need to pass \u0060teams[i].members\u0060 to the \u0060getMembers\u0060 generator function. The generator function returns a generator object. In order to iterate over each element in this generator object, we need to use \u0060yield*\u0060.\n\nIf we would\u0027ve written \u0060yield\u0060, \u0060return yield\u0060, or \u0060return\u0060, the entire generator function would\u0027ve gotten returned the first time we called the \u0060next\u0060 method."
  },
  {
    "id": "141",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst person = {\n  name: \u0027Lydia Hallie\u0027,\n  hobbies: [\u0027coding\u0027],\n};\n\nfunction addHobby(hobby, hobbies = person.hobbies) {\n  hobbies.push(hobby);\n  return hobbies;\n}\n\naddHobby(\u0027running\u0027, []);\naddHobby(\u0027dancing\u0027);\naddHobby(\u0027baking\u0027, person.hobbies);\n\nconsole.log(person.hobbies);\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[\u0022coding\u0022]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[\u0022coding\u0022, \u0022dancing\u0022]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[\u0022coding\u0022, \u0022dancing\u0022, \u0022baking\u0022]",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "[\u0022coding\u0022, \u0022running\u0022, \u0022dancing\u0022, \u0022baking\u0022]",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060addHobby\u0060 function receives two arguments, \u0060hobby\u0060 and \u0060hobbies\u0060 with the default value of the \u0060hobbies\u0060 array on the \u0060person\u0060 object.\n\nFirst, we invoke the \u0060addHobby\u0060 function, and pass \u0060\u0022running\u0022\u0060 as the value for \u0060hobby\u0060 and an empty array as the value for \u0060hobbies\u0060. Since we pass an empty array as the value for \u0060hobbies\u0060, \u0060\u0022running\u0022\u0060 gets added to this empty array.\n\nThen, we invoke the \u0060addHobby\u0060 function, and pass \u0060\u0022dancing\u0022\u0060 as the value for \u0060hobby\u0060. We didn\u0027t pass a value for \u0060hobbies\u0060, so it gets the default value, the \u0060hobbies\u0060 property on the \u0060person\u0060 object. We push the hobby \u0060dancing\u0060 to the \u0060person.hobbies\u0060 array.\n\nLast, we invoke the \u0060addHobby\u0060 function, and pass \u0060\u0022baking\u0022\u0060 as the value for \u0060hobby\u0060, and the \u0060person.hobbies\u0060 array as the value for \u0060hobbies\u0060. We push the hobby \u0060baking\u0060 to the \u0060person.hobbies\u0060 array.\n\nAfter pushing \u0060dancing\u0060 and \u0060baking\u0060, the value of \u0060person.hobbies\u0060 is \u0060[\u0022coding\u0022, \u0022dancing\u0022, \u0022baking\u0022]\u0060"
  },
  {
    "id": "142",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nclass Bird {\n  constructor() {\n    console.log(\u0022I\u0027m a bird. \uD83E\uDDA2\u0022);\n  }\n}\n\nclass Flamingo extends Bird {\n  constructor() {\n    console.log(\u0022I\u0027m pink. \uD83C\uDF38\u0022);\n    super();\n  }\n}\n\nconst pet = new Flamingo();\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "I\u0027m pink. \uD83C\uDF38",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "I\u0027m pink. \uD83C\uDF38 I\u0027m a bird. \uD83E\uDDA2",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "I\u0027m a bird. \uD83E\uDDA2 I\u0027m pink. \uD83C\uDF38",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "Nothing, we didn\u0027t call any method",
        "isCorrect": false
      }
    ],
    "explanation": "We create the variable \u0060pet\u0060 which is an instance of the \u0060Flamingo\u0060 class. When we instantiate this instance, the \u0060constructor\u0060 on \u0060Flamingo\u0060 gets called. First, \u0060\u0022I\u0027m pink. \uD83C\uDF38\u0022\u0060 gets logged, after which we call \u0060super()\u0060. \u0060super()\u0060 calls the constructor of the parent class, \u0060Bird\u0060. The constructor in \u0060Bird\u0060 gets called, and logs \u0060\u0022I\u0027m a bird. \uD83E\uDDA2\u0022\u0060."
  },
  {
    "id": "143",
    "question": "Which of the options result(s) in an error?\n\n\u0060\u0060\u0060javascript\nconst emojis = [\u0027\uD83C\uDF84\u0027, \u0027\uD83C\uDF85\uD83C\uDFFC\u0027, \u0027\uD83C\uDF81\u0027, \u0027\u2B50\u0027];\n\n/* 1 */ emojis.push(\u0027\uD83E\uDD8C\u0027);\n/* 2 */ emojis.splice(0, 2);\n/* 3 */ emojis = [...emojis, \u0027\uD83E\uDD42\u0027];\n/* 4 */ emojis.length = 0;\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "1",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "1 and 2",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "3 and 4",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "3",
        "isCorrect": true
      }
    ],
    "explanation": "The \u0060const\u0060 keyword simply means we cannot _redeclare_ the value of that variable, it\u0027s _read-only_. However, the value itself isn\u0027t immutable. The properties on the \u0060emojis\u0060 array can be modified, for example by pushing new values, splicing them, or setting the length of the array to 0."
  },
  {
    "id": "144",
    "question": "What do we need to add to the \u0060person\u0060 object to get \u0060[\u0022Lydia Hallie\u0022, 21]\u0060 as the output of \u0060[...person]\u0060?\n\n\u0060\u0060\u0060javascript\nconst person = {\n  name: \u0022Lydia Hallie\u0022,\n  age: 21\n}\n\n[...person] // [\u0022Lydia Hallie\u0022, 21]\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "Nothing, object are iterable by default",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "*[Symbol.iterator]() { for (let x in this) yield* this[x] }",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "*[Symbol.iterator]() { yield* Object.values(this) }",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "*[Symbol.iterator]() { for (let x in this) yield this }",
        "isCorrect": false
      }
    ],
    "explanation": "Objects aren\u0027t iterable by default. An iterable is an iterable if the iterator protocol is present. We can add this manually by adding the iterator symbol \u0060[Symbol.iterator]\u0060, which has to return a generator object, for example by making it a generator function \u0060*[Symbol.iterator]() {}\u0060. This generator function has to yield the \u0060Object.values\u0060 of the \u0060person\u0060 object if we want it to return the array \u0060[\u0022Lydia Hallie\u0022, 21]\u0060: \u0060yield* Object.values(this)\u0060."
  },
  {
    "id": "145",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nlet count = 0;\nconst nums = [0, 1, 2, 3];\n\nnums.forEach(num =\u003E {\n\tif (num) count \u002B= 1\n})\n\nconsole.log(count)\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "1",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "2",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "3",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "4",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060if\u0060 condition within the \u0060forEach\u0060 loop checks whether the value of \u0060num\u0060 is truthy or falsy. Since the first number in the \u0060nums\u0060 array is \u00600\u0060, a falsy value, the \u0060if\u0060 statement\u0027s code block won\u0027t be executed. \u0060count\u0060 only gets incremented for the other 3 numbers in the \u0060nums\u0060 array, \u00601\u0060, \u00602\u0060 and \u00603\u0060. Since \u0060count\u0060 gets incremented by \u00601\u0060 3 times, the value of \u0060count\u0060 is \u00603\u0060."
  },
  {
    "id": "146",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nfunction getFruit(fruits) {\n\tconsole.log(fruits?.[1]?.[1])\n}\n\ngetFruit([[\u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4C\u0027], [\u0027\uD83C\uDF4D\u0027]])\ngetFruit()\ngetFruit([[\u0027\uD83C\uDF4D\u0027], [\u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4C\u0027]])\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "null, undefined, \uD83C\uDF4C",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[], null, \uD83C\uDF4C",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[], [], \uD83C\uDF4C",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined, undefined, \uD83C\uDF4C",
        "isCorrect": true
      }
    ],
    "explanation": "The \u0060?\u0060 allows us to optionally access deeper nested properties within objects. We\u0027re trying to log the item on index \u00601\u0060 within the subarray that\u0027s on index \u00601\u0060 of the \u0060fruits\u0060 array. If the subarray on index \u00601\u0060 in the \u0060fruits\u0060 array doesn\u0027t exist, it\u0027ll simply return \u0060undefined\u0060. If the subarray on index \u00601\u0060 in the \u0060fruits\u0060 array exists, but this subarray doesn\u0027t have an item on its \u00601\u0060 index, it\u0027ll also return \u0060undefined\u0060. \n\nFirst, we\u0027re trying to log the second item in the \u0060[\u0027\uD83C\uDF4D\u0027]\u0060 subarray of \u0060[[\u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4C\u0027], [\u0027\uD83C\uDF4D\u0027]]\u0060. This subarray only contains one item, which means there is no item on index \u00601\u0060, and returns \u0060undefined\u0060.\n\nThen, we\u0027re invoking the \u0060getFruits\u0060 function without passing a value as an argument, which means that \u0060fruits\u0060 has a value of \u0060undefined\u0060 by default. Since we\u0027re conditionally chaining the item on index \u00601\u0060 of\u0060fruits\u0060, it returns \u0060undefined\u0060 since this item on index \u00601\u0060 does not exist. \n\nLastly, we\u0027re trying to log the second item in the \u0060[\u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4C\u0027]\u0060 subarray of \u0060[\u0027\uD83C\uDF4D\u0027], [\u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4C\u0027]\u0060. The item on index \u00601\u0060 within this subarray is \u0060\uD83C\uDF4C\u0060, which gets logged."
  },
  {
    "id": "147",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nclass Calc {\n\tconstructor() {\n\t\tthis.count = 0 \n\t}\n\n\tincrease() {\n\t\tthis.count \u002B\u002B\n\t}\n}\n\nconst calc = new Calc()\nnew Calc().increase()\n\nconsole.log(calc.count)\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "0",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "1",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "We set the variable \u0060calc\u0060 equal to a new instance of the \u0060Calc\u0060 class. Then, we instantiate a new instance of \u0060Calc\u0060, and invoke the \u0060increase\u0060 method on this instance. Since the count property is within the constructor of the \u0060Calc\u0060 class, the count property is not shared on the prototype of \u0060Calc\u0060. This means that the value of count has not been updated for the instance calc points to, count is still \u00600\u0060."
  },
  {
    "id": "148",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst user = {\n\temail: \u0022e@mail.com\u0022,\n\tpassword: \u002212345\u0022\n}\n\nconst updateUser = ({ email, password }) =\u003E {\n\tif (email) {\n\t\tObject.assign(user, { email })\n\t}\n\n\tif (password) {\n\t\tuser.password = password\n\t}\n\n\treturn user\n}\n\nconst updatedUser = updateUser({ email: \u0022new@email.com\u0022 })\n\nconsole.log(updatedUser === user)\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "false",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "true",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "TypeError",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060updateUser\u0060 function updates the values of the \u0060email\u0060 and \u0060password\u0060 properties on user, if their values are passed to the function, after which the function returns the \u0060user\u0060 object. The returned value of the \u0060updateUser\u0060 function is the \u0060user\u0060 object, which means that the value of updatedUser is a reference to the same \u0060user\u0060 object that \u0060user\u0060 points to. \u0060updatedUser === user\u0060 equals \u0060true\u0060."
  },
  {
    "id": "149",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst fruit = [\u0027\uD83C\uDF4C\u0027, \u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4E\u0027]\n\nfruit.slice(0, 1)\nfruit.splice(0, 1)\nfruit.unshift(\u0027\uD83C\uDF47\u0027)\n\nconsole.log(fruit)\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[\u0027\uD83C\uDF4C\u0027, \u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4E\u0027]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[\u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4E\u0027]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[\u0027\uD83C\uDF47\u0027, \u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4E\u0027]",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "[\u0027\uD83C\uDF47\u0027, \u0027\uD83C\uDF4C\u0027, \u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4E\u0027]",
        "isCorrect": false
      }
    ],
    "explanation": "First, we invoke the \u0060slice\u0060 method on the fruit array. The slice method does not modify the original array, but returns the value that it sliced off the array: the banana emoji.\nThen, we invoke the \u0060splice\u0060 method on the fruit array. The splice method does modify the original array, which means that the fruit array now consists of \u0060[\u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4E\u0027]\u0060.\nAt last, we invoke the \u0060unshift\u0060 method on the \u0060fruit\u0060 array, which modifies the original array by adding the provided value, \u2018\uD83C\uDF47\u2019 in this case,  as the first element in the array.  The fruit array now consists of \u0060[\u0027\uD83C\uDF47\u0027, \u0027\uD83C\uDF4A\u0027, \u0027\uD83C\uDF4E\u0027]\u0060."
  },
  {
    "id": "150",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst animals = {};\nlet dog = { emoji: \u0027\uD83D\uDC36\u0027 }\nlet cat = { emoji: \u0027\uD83D\uDC08\u0027 }\n\nanimals[dog] = { ...dog, name: \u0022Mara\u0022 }\nanimals[cat] = { ...cat, name: \u0022Sara\u0022 }\n\nconsole.log(animals[dog])\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{ emoji: \u0022\uD83D\uDC36\u0022, name: \u0022Mara\u0022 }",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "{ emoji: \u0022\uD83D\uDC08\u0022, name: \u0022Sara\u0022 }",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "Object keys are converted to strings. \n\nSince the value of  \u0060dog\u0060 is an object,  \u0060animals[dog]\u0060 actually means that we\u2019re creating a new property called \u0060\u0022object Object\u0022\u0060 equal to the new object. \u0060animals[\u0022object Object\u0022]\u0060 is now equal to \u0060{ emoji: \u0022\uD83D\uDC36\u0022, name: \u0022Mara\u0022}\u0060.\n\n\u0060cat\u0060 is also an object, which means that \u0060animals[cat]\u0060 actually means that we\u2019re overwriting the value of  \u0060animals[\u0022object Object\u0022]\u0060 with the new cat properties. \n\nLogging \u0060animals[dog]\u0060, or actually \u0060animals[\u0022object Object\u0022]\u0060 since converting the \u0060dog\u0060 object to a string results \u0060\u0022object Object\u0022\u0060, returns the \u0060{ emoji: \u0022\uD83D\uDC08\u0022, name: \u0022Sara\u0022 }\u0060."
  },
  {
    "id": "151",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst user = {\n\temail: \u0022my@email.com\u0022,\n\tupdateEmail: email =\u003E {\n\t\tthis.email = email\n\t}\n}\n\nuser.updateEmail(\u0022new@email.com\u0022)\nconsole.log(user.email)\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "my@email.com",
        "isCorrect": true
      },
      {
        "index": "B",
        "answer": "new@email.com",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "undefined",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "ReferenceError",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060updateEmail\u0060 function is an arrow function, and is not bound to the \u0060user\u0060 object. This means that the \u0060this\u0060 keyword is not referring to the \u0060user\u0060 object, but refers to  the global scope in this case. The value of \u0060email\u0060 within the \u0060user\u0060 object does not get updated. When logging the value of \u0060user.email\u0060, the original value of \u0060my@email.com\u0060 gets returned."
  },
  {
    "id": "152",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst promise1 = Promise.resolve(\u0027First\u0027)\nconst promise2 = Promise.resolve(\u0027Second\u0027)\nconst promise3 = Promise.reject(\u0027Third\u0027)\nconst promise4 = Promise.resolve(\u0027Fourth\u0027)\n\nconst runPromises = async () =\u003E {\n\tconst res1 = await Promise.all([promise1, promise2])\n\tconst res2  = await Promise.all([promise3, promise4])\n\treturn [res1, res2]\n}\n\nrunPromises()\n\t.then(res =\u003E console.log(res))\n\t.catch(err =\u003E console.log(err))\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "[[\u0027First\u0027, \u0027Second\u0027], [\u0027Fourth\u0027]]",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "[[\u0027First\u0027, \u0027Second\u0027], [\u0027Third\u0027, \u0027Fourth\u0027]]",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "[[\u0027First\u0027, \u0027Second\u0027]]",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "\u0027Third\u0027",
        "isCorrect": true
      }
    ],
    "explanation": "The \u0060Promise.all\u0060 method runs the passed promises in parallel. If one promise fails, the \u0060Promise.all\u0060 method _rejects_ with the value of the rejected promise. In this case, \u0060promise3\u0060 rejected with the value \u0060\u0022Third\u0022\u0060. We\u2019re catching the rejected value in the chained \u0060catch\u0060 method on the \u0060runPromises\u0060 invocation to catch any errors  within the \u0060runPromises\u0060 function. Only \u0060\u0022Third\u0022\u0060 gets logged, since \u0060promise3\u0060 rejected with this value."
  },
  {
    "id": "153",
    "question": "What should the value of \u0060method\u0060 be to log \u0060{ name: \u0022Lydia\u0022, age: 22 }\u0060? \n\n\u0060\u0060\u0060javascript\nconst keys = [\u0022name\u0022, \u0022age\u0022]\nconst values = [\u0022Lydia\u0022, 22]\n\nconst method = /* ?? */\nObject[method](keys.map((_, i) =\u003E {\n\treturn [keys[i], values[i]]\n})) // { name: \u0022Lydia\u0022, age: 22 }\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "entries",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "values",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "fromEntries",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "forEach",
        "isCorrect": false
      }
    ],
    "explanation": "The \u0060fromEntries\u0060 method turns a 2d array into an object. The first element in each subarray will be the key, and the second element in each subarray will be the value. In this case, we\u2019re mapping over the \u0060keys\u0060 array, which returns an array which first element is the item on the key array on the current index, and the second element is the item of the values array on the current index. \n\nThis creates an array of subarrays containing the correct keys and values, which results in \u0060{ name: \u0022Lydia\u0022, age: 22 }\u0060"
  },
  {
    "id": "154",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nconst createMember = ({ email, address = {}}) =\u003E {\n\tconst validEmail = /.\u002B\\@.\u002B\\..\u002B/.test(email)\n\tif (!validEmail) throw new Error(\u0022Valid email pls\u0022)\n\n\treturn {\n\t\temail,\n\t\taddress: address ? address : null\n\t}\n}\n\nconst member = createMember({ email: \u0022my@email.com\u0022 })\nconsole.log(member)\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "{ email: \u0022my@email.com\u0022, address: null }",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "{ email: \u0022my@email.com\u0022 }",
        "isCorrect": false
      },
      {
        "index": "C",
        "answer": "{ email: \u0022my@email.com\u0022, address: {} }",
        "isCorrect": true
      },
      {
        "index": "D",
        "answer": "{ email: \u0022my@email.com\u0022, address: undefined }",
        "isCorrect": false
      }
    ],
    "explanation": "The default value of \u0060address\u0060 is an empty object \u0060{}\u0060. When we set the variable \u0060member\u0060 equal to the object returned by the \u0060createMember\u0060 function, we didn\u0027t pass a value for address, which means that the value of address is the default empty object \u0060{}\u0060. An empty object is a truthy value, which means that the condition of the \u0060address ? address : null\u0060 conditional returns \u0060true\u0060. The value of address is the empty object \u0060{}\u0060."
  },
  {
    "id": "155",
    "question": "What\u0027s the output?\n\n\u0060\u0060\u0060javascript\nlet randomValue = { name: \u0022Lydia\u0022 }\nrandomValue = 23\n\nif (!typeof randomValue === \u0022string\u0022) {\n\tconsole.log(\u0022It\u0027s not a string!\u0022)\n} else {\n\tconsole.log(\u0022Yay it\u0027s a string!\u0022)\n}\n\u0060\u0060\u0060",
    "answers": [
      {
        "index": "A",
        "answer": "It\u0027s not a string!",
        "isCorrect": false
      },
      {
        "index": "B",
        "answer": "Yay it\u0027s a string!",
        "isCorrect": true
      },
      {
        "index": "C",
        "answer": "TypeError",
        "isCorrect": false
      },
      {
        "index": "D",
        "answer": "undefined",
        "isCorrect": false
      }
    ],
    "explanation": "The condition within the \u0060if\u0060 statement checks whether the value of \u0060!typeof randomValue\u0060 is equal to \u0060\u0022string\u0022\u0060. The \u0060!\u0060 operator converts the value to a boolean value. If the value is truthy, the returned value will be \u0060false\u0060, if the value is falsy, the returned value will be \u0060true\u0060. In this case, the returned value of \u0060typeof randomValue\u0060 is the truthy value \u0060\u0022number\u0022\u0060, meaning that the value of \u0060!typeof randomValue\u0060 is the boolean value \u0060false\u0060.\n\n\u0060!typeof randomValue === \u0022string\u0022\u0060 always returns false, since we\u0027re actually checking \u0060false === \u0022string\u0022\u0060. Since the condition returned \u0060false\u0060, the code block of the \u0060else\u0060 statement gets run, and \u0060Yay it\u0027s a string!\u0060 gets logged."
  }
]